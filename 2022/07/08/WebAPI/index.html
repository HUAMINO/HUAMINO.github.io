<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="webApi">
<meta property="og:type" content="article">
<meta property="og:title" content="webApi">
<meta property="og:url" content="http://example.com/2022/07/08/WebAPI/index.html">
<meta property="og:site_name" content="石化敏的博客">
<meta property="og:description" content="webApi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655291423814-aaf56a36-de39-4bc4-a745-55aaab9d901a.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655291141489-eaccf24e-d38a-4b97-b819-f7fea165f42c.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655291287386-5cf98408-9d4d-4670-8980-724e0872c435.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655535362847-85c347d7-4240-4fa1-a28d-b50ae03ebb4d.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655535369805-ccf6fc8c-a8f7-429d-8287-05fdbc29e86f.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655535293682-66006c3b-654a-4c7f-a8e7-cec71a7b7a80.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655535308517-97502e62-3615-480e-a5f3-a9c79fdaf9e2.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655632444007-b812da43-4f08-42c2-bb0f-a4e0ac56af99.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655814080172-8ceb02a0-08c0-4629-a832-729205e70cca.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655814522431-1ab5edc6-b653-42a9-bc4b-31eafed53044.png">
<meta property="article:published_time" content="2022-07-08T08:27:44.000Z">
<meta property="article:modified_time" content="2022-07-09T00:40:31.215Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655291423814-aaf56a36-de39-4bc4-a745-55aaab9d901a.png">

<link rel="canonical" href="http://example.com/2022/07/08/WebAPI/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>webApi | 石化敏的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>




<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">石化敏的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">无论什么时候都不要把自己当一回事，要把自己做的事情当一回事—-胡歌</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">4</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/08/WebAPI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="石化敏的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          webApi
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-08 16:27:44" itemprop="dateCreated datePublished" datetime="2022-07-08T16:27:44+08:00">2022-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-09 08:40:31" itemprop="dateModified" datetime="2022-07-09T08:40:31+08:00">2022-07-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/webApi/" itemprop="url" rel="index"><span itemprop="name">webApi</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <div class="post-description">webApi</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>application programming interface 应用程序接口，  api = 接口</p>
<p>接口：在程序里面，接口可以看做是以个方法或者一个函数或者工具</p>
<h3 id="web-API"><a href="#web-API" class="headerlink" title="web API"></a>web API</h3><p>web api = dom + bom</p>
<p>主要针对网页游览器的交互效果 主要是dom和bom</p>
<h2 id="Dom"><a href="#Dom" class="headerlink" title="Dom"></a>Dom</h2><p>文档对象模型  顶级对象就是 document</p>
<p>一个页面就是文档，把页面看做一个对象。</p>
<p>处理页面和网页的内容和结构</p>
<p>dom树</p>
<p>元素:页面上所有的标签都是元素： h1 div span</p>
<p>节点：node页面中所有的内容都是节点；</p>
<h3 id="文档模型"><a href="#文档模型" class="headerlink" title="文档模型"></a>文档模型</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655291423814-aaf56a36-de39-4bc4-a745-55aaab9d901a.png" alt="img"></p>
<h3 id="节点Node-–构成html文档最基本的单元"><a href="#节点Node-–构成html文档最基本的单元" class="headerlink" title="节点Node –构成html文档最基本的单元"></a>节点Node –构成html文档最基本的单元</h3><ul>
<li>文档节点：整个HTML文档  document</li>
<li>元素节点：HTML文档中的html标签</li>
<li>属性节点：元素的属性</li>
<li>文本节点：HTML标签中的文本内容</li>
<li>注释节点：页面中的注释</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655291141489-eaccf24e-d38a-4b97-b819-f7fea165f42c.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655291287386-5cf98408-9d4d-4670-8980-724e0872c435.png" alt="img"></p>
<h4 id="文档节点"><a href="#文档节点" class="headerlink" title="文档节点"></a>文档节点</h4><p>游览器已经为我们提供文档节点，对象这个对象是window属性</p>
<p>可以在页面中直接使用，文档节点代表的是整个网页</p>
<p>document.getElementById(“btn”);</p>
<p>innderHmL修改html内部的代码（）</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><h4 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById()"></a>getElementById()</h4><ul>
<li><strong>定义</strong>： 通过id属性获取一个元素节点对象</li>
</ul>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>console.dir(div) 打印一个对象的所有属性和方法</p>
<h4 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName();"></a>getElementsByTagName();</h4><ul>
<li><strong>定义</strong>：通过标签名获取一组元素节点对象</li>
<li><strong>返回值</strong>：获取所有选中的元素集合，返回的是伪数组，元素集合</li>
<li><strong>伪数组</strong>：有length,有索引你，没有数组的方法</li>
<li>** 注意点**：即使查询到的元素只有一个，也会封装到数组中返回</li>
<li>如果页面上没有这个元素就会返回一个空的伪数组。</li>
</ul>
<p>如果想要打印出每一个li元素，for循环遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">         console.log(lis[i]);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取到id为ol下的所有li标签"><a href="#获取到id为ol下的所有li标签" class="headerlink" title="获取到id为ol下的所有li标签"></a>获取到id为ol下的所有li标签</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol id=&quot;ol&quot;&gt;&lt;li&gt;生僻字&lt;/li&gt; &lt;/ol&gt;</span><br><span class="line">var ol = document.getElementById(&#x27;ol&#x27;);</span><br><span class="line">var list = ol.getElementsByTagName(&#x27;li&#x27;);</span><br><span class="line">console.log(list);</span><br></pre></td></tr></table></figure>

<h4 id="如果通过tagname-获取，先得到的是伪数组"><a href="#如果通过tagname-获取，先得到的是伪数组" class="headerlink" title="如果通过tagname 获取，先得到的是伪数组"></a>如果通过tagname 获取，先得到的是伪数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt;</span><br><span class="line">&lt;ol&gt;&lt;/ol&gt;</span><br><span class="line"></span><br><span class="line">var ols = document.getElementsByTagName(&#x27;ol&#x27;);</span><br><span class="line">var lis_first = ols[0].document.getElementsByTagName(&#x27;li&#x27;)</span><br><span class="line">         console.log(lis_first);</span><br></pre></td></tr></table></figure>

<p>以下是h5新增属性</p>
<h4 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName()"></a>getElementsByClassName()</h4><ul>
<li><strong>定义</strong>：通过name属性获取一组元素节点对象称为一个数组</li>
<li><strong>注意</strong>：类名里面不需要写  . 存在兼容问题ie8不支持</li>
<li><strong>返回值</strong>：返回的是一个伪数组，集合</li>
<li>虽然ie8中没有getElemetByClassName但是可以使用querySelector()</li>
</ul>
<h4 id="document-querySelector"><a href="#document-querySelector" class="headerlink" title="document.querySelector();"></a>document.querySelector();</h4><p><strong>定义</strong>：通过选择器来获取元素</p>
<p><strong>注意</strong>：里面可以写 id ，类，标签，id，类名需要(#  . )</p>
<p><strong>返回值：</strong>返回的是获取到的第一个元素</p>
<p>使用该方法总会返回唯一的一个元素，如果满足条件的有很多个那他只返回第一个                    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var lis4 = document.querySelector(&#x27;#nav li&#x27;)</span><br></pre></td></tr></table></figure>

<h4 id="document-querySelectorAll"><a href="#document-querySelectorAll" class="headerlink" title="document.querySelectorAll();"></a>document.querySelectorAll();</h4><ul>
<li><strong>定义</strong>：返回指定选择器的所有元素对象的集合，一推，伪数组。</li>
<li><strong>注意</strong>：1.获取到的是一堆元素集合2.类名，id都需要加</li>
</ul>
<h4 id="开发中的简介写法"><a href="#开发中的简介写法" class="headerlink" title="开发中的简介写法"></a>开发中的简介写法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = document.querySelector(&#x27;#nav ul  li:last-child&#x27;)</span><br></pre></td></tr></table></figure>

<h4 id="特殊的两个"><a href="#特殊的两个" class="headerlink" title="特殊的两个"></a>特殊的两个</h4><p>获取body元素</p>
<p>document.body</p>
<p>获取html元素</p>
<p>document.html</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><strong>定义：</strong>页面上每个元素都可以触发一些js事件；触发-响应的机制</p>
<p>​            就是文档或游览器窗口中发生的一些特定的相互瞬间</p>
<p><strong>拓展</strong>：javaScript与HTML之间的交互是通过事件实现的</p>
<h4 id="事件三要素"><a href="#事件三要素" class="headerlink" title="事件三要素"></a>事件三要素</h4><p><strong>事件源</strong>：谁，哪个元素</p>
<p><strong>事件类型</strong>：触发了什么事件，点击事件，鼠标移入移出事件，键盘按下，抬起</p>
<p><strong>事件处理程序</strong>：我们要做什么，干嘛</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取事件源</span><br><span class="line">       var btn = document.querySelector(&#x27;#btn&#x27;);</span><br><span class="line">       console.log(btn);</span><br><span class="line">       //2.注册事件，(绑定事件) On当什么什么的时候，click点击</span><br><span class="line">       btn.onclick = function() &#123;</span><br><span class="line">           //3.事件处理程序</span><br><span class="line">         this.btn =====  当前的btn按钮，也就是事件源</span><br><span class="line">           console.log(&#x27;点秋香&#x27;);         </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="鼠标的一些相关事件"><a href="#鼠标的一些相关事件" class="headerlink" title="鼠标的一些相关事件"></a>鼠标的一些相关事件</h4><table>
<thead>
<tr>
<th><strong>鼠标事件</strong></th>
<th><strong>触发条件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>onclick</td>
<td>鼠标点击左键触发</td>
</tr>
<tr>
<td>onmouseover</td>
<td>鼠标进入时触发</td>
</tr>
<tr>
<td>onmouseout</td>
<td>鼠标离开触发</td>
</tr>
<tr>
<td>onfocus</td>
<td>获取鼠标焦点触发</td>
</tr>
<tr>
<td>onblur</td>
<td>失去鼠标焦点触发</td>
</tr>
<tr>
<td>onmousemove</td>
<td>鼠标移动触发</td>
</tr>
<tr>
<td>onmouseup</td>
<td>鼠标弹起触发</td>
</tr>
<tr>
<td>onmousedown</td>
<td>鼠标按下触发</td>
</tr>
</tbody></table>
<h4 id="clientX和clientY"><a href="#clientX和clientY" class="headerlink" title="clientX和clientY"></a>clientX和clientY</h4><p>获取对应的x和y的坐标</p>
<p>注意只能是当前游览器窗口的位移。</p>
<h4 id="pageX-pageY"><a href="#pageX-pageY" class="headerlink" title="pageX,pageY"></a>pageX,pageY</h4><p>是整个游览器的偏移量包括未显示的</p>
<p>注意：这两个属性在ie8中不支持</p>
<h3 id="事件冒泡："><a href="#事件冒泡：" class="headerlink" title="事件冒泡："></a>事件冒泡：</h3><p>所谓的冒泡就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  &lt;div class=&quot;boxd&quot;&gt;</span><br><span class="line">    &lt;span&gt;ddd&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">div.onclick</span><br><span class="line">span.onclick</span><br><span class="line">//当我们点击span时会触发span 也会触发父元素</span><br><span class="line">在开发中大部分的冒泡都是很有用的，如果不希望发生事件冒泡可以通过事件对象来取消冒泡</span><br><span class="line"></span><br><span class="line">e.stopPropagation 阻止事件冒泡</span><br></pre></td></tr></table></figure>

<h3 id="操作元素并改变元素内容"><a href="#操作元素并改变元素内容" class="headerlink" title="操作元素并改变元素内容"></a>操作元素并改变元素内容</h3><h4 id="innderHmL-和-innerText的相同点"><a href="#innderHmL-和-innerText的相同点" class="headerlink" title="innderHmL 和 innerText的相同点"></a>innderHmL 和 innerText的相同点</h4><p>都可以修改文本的内容,同时可以获取里面文本的值</p>
<h4 id="innerText-和-innderHmL的区别"><a href="#innerText-和-innderHmL的区别" class="headerlink" title="innerText 和 innderHmL的区别"></a>innerText 和 innderHmL的区别</h4><p>innerText：不识别htmL标签，非标准，去除空格和换行</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655535362847-85c347d7-4240-4fa1-a28d-b50ae03ebb4d.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655535369805-ccf6fc8c-a8f7-429d-8287-05fdbc29e86f.png" alt="img"></p>
<p>innerHtml：识别htmL标签，标准，保留空格和换行</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655535293682-66006c3b-654a-4c7f-a8e7-cec71a7b7a80.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655535308517-97502e62-3615-480e-a5f3-a9c79fdaf9e2.png" alt="img"></p>
<h3 id="常见修改属性操作"><a href="#常见修改属性操作" class="headerlink" title="常见修改属性操作"></a>常见修改属性操作</h3><p>元素对象.属性</p>
<p>var img = document.querySelector(‘img’);</p>
<p>img.src = ‘images/s.gif’</p>
<h3 id="操作元素之修改样式属性"><a href="#操作元素之修改样式属性" class="headerlink" title="操作元素之修改样式属性"></a>操作元素之修改样式属性</h3><h4 id="通过style来修改"><a href="#通过style来修改" class="headerlink" title="通过style来修改"></a>通过style来修改</h4><p>element.style.样式值 = 值；</p>
<p><strong>注意：复合属性 要改写成驼峰形式    ，修改style 宽高等一定要加上px，字符串。并且url(也需要)</strong></p>
<p>var div = document.querySelector(“div”)</p>
<p>div.style.width = ‘300px’;</p>
<p>div.style.backgroundClor = ‘orange’</p>
<p>div.style.borderRadius= ‘orange’</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">div.onclick = function () &#123;</span><br><span class="line">    div.style.width = &#x27;300px&#x27;</span><br><span class="line">    div.style.backgroundColor = &#x27;orange&#x27; </span><br><span class="line">        // 3. this指向</span><br><span class="line">        console.log(this)</span><br><span class="line">        // this指向的是绑定事件的元素</span><br><span class="line">        this.style.marginTop = &#x27;200px&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getComputedStyle"><a href="#getComputedStyle" class="headerlink" title="getComputedStyle()"></a>getComputedStyle()</h4><p>定义：这个方法是window的方法，可以直接使用</p>
<p>需要两个参数：</p>
<p>第一个：要获取样式的元素</p>
<p>第二个：可以传递一个伪元素，一般都传null</p>
<h4 id="通过className来修改样式"><a href="#通过className来修改样式" class="headerlink" title="通过className来修改样式"></a>通过className来修改样式</h4><p>**className 会覆盖原本自身带的类名  **</p>
<p>可以通过来写多个类名来实现   this.className = ‘first change’</p>
<p><strong>注意：适合多个样式都要修改的时候</strong></p>
<p><strong>可以this.className = ‘’</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.first &#123;</span><br><span class="line">&#125;</span><br><span class="line">this.className = &#x27;first&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="排他思想"><a href="#排他思想" class="headerlink" title="排他思想"></a>排他思想</h3><p>干掉所有的，留下自己的。</p>
<p><strong>使用地方</strong>：如果有相同的一组元素，我们要给某一个元素设置某种样式，就可以用到排他思想</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//1. 获取所有按钮元素</span><br><span class="line">       var btns = document.getElementsByTagName(&#x27;button&#x27;);</span><br><span class="line">       // btns得到的是伪数组  里面的每一个元素 btns[i]</span><br><span class="line">       for (var i = 0; i &lt; btns.length; i++) &#123;</span><br><span class="line">   //应为这些btns已经在数组里面了当你点击网页上的按钮时,就已经获得了这个元素i</span><br><span class="line">           btns[i].onclick = function() &#123;</span><br><span class="line">               //(1) 我们先把所有的按钮背景颜色去掉  干掉所有人</span><br><span class="line">               for (var i = 0; i &lt; btns.length; i++) &#123;</span><br><span class="line">                   btns[i].style.backgroundColor = &#x27;&#x27;;</span><br><span class="line">               &#125;</span><br><span class="line">               //(2) 然后才让当前的元素背景颜色为pink 留下我自己</span><br><span class="line">               this.style.backgroundColor = &#x27;pink&#x27;;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：this.style.backgroundColor = ‘pink’  不能写成 btns[i].style.backgroundColor</strong></p>
<p><strong>应为外面的for循环已经跑完，所以i已经变成了5 如果是btns[i] 就一直是这个undefined;</strong></p>
<h3 id="自定义属性的操作"><a href="#自定义属性的操作" class="headerlink" title="自定义属性的操作"></a>自定义属性的操作</h3><h4 id="获取元素属性："><a href="#获取元素属性：" class="headerlink" title="获取元素属性："></a>获取元素属性：</h4><p><strong>语法</strong>：element.属性     </p>
<p><strong>注意</strong>：只能是元素本身的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot; index=&quot;1&quot; person = &quot;张三&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;</span><br><span class="line">console.log(div.id); // 1</span><br><span class="line">console.log(div.className);  // nav</span><br><span class="line"> 属性不能使用 element.属性</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="获取元素自定义属性"><a href="#获取元素自定义属性" class="headerlink" title="获取元素自定义属性"></a>获取元素自定义属性</h4><p><strong>语法****：</strong>getAttribute(‘属性名’)  </p>
<p><strong>注意：</strong> 可以同时获取元素本身属性和自定义属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot; index=&quot;1&quot; person = &quot;张三&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;</span><br><span class="line">console.log(div.getAttribute(&#x27;index&#x27;));</span><br><span class="line">console.log(div.getAttribute(&#x27;id&#x27;));</span><br><span class="line">console.log(div.getAttribute(&#x27;class&#x27;));</span><br><span class="line">console.log(div.getAttribute(&#x27;person&#x27;));</span><br></pre></td></tr></table></figure>

<h4 id="设置元素属性"><a href="#设置元素属性" class="headerlink" title="设置元素属性"></a>设置元素属性</h4><p><strong>语法</strong>：element.属性     =  ‘值’；</p>
<p><strong>注意</strong>：只能是元素本身的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot; index=&quot;1&quot; person = &quot;张三&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;</span><br><span class="line">div.id = &#x27;2&#x27;;</span><br><span class="line">div.className = &#x27;ddd&#x27;</span><br><span class="line">console.log(div.id)</span><br></pre></td></tr></table></figure>

<h4 id="设置元素自定义属性"><a href="#设置元素自定义属性" class="headerlink" title="设置元素自定义属性"></a>设置元素自定义属性</h4><p><strong>语法</strong>：element.setAttribute(‘属性名’,’值’)  </p>
<p><strong>注意：</strong> 可以同时获取元素本身属性和自定义属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot; index=&quot;1&quot; person = &quot;张三&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;</span><br><span class="line">div.setAttribute(&#x27;id&#x27;,&#x27;3&#x27;)</span><br><span class="line">console.log(div.id);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="dataset获取自定义属性"><a href="#dataset获取自定义属性" class="headerlink" title="dataset获取自定义属性"></a>dataset获取自定义属性</h3><p> <strong>定义</strong>：h5新增的获取自定义属性的方法 它只能获取data-开头的</p>
<p>** 说明：** dataset 是一个集合里面存放了所有以data开头的自定义属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;</span><br><span class="line">console.log(div.dataset.index); //2</span><br><span class="line">console.log(div.dataset[&#x27;index&#x27;]);</span><br><span class="line">// 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法</span><br><span class="line">console.log(div.dataset.listName);//andy</span><br><span class="line">console.log(div.dataset[&#x27;listName&#x27;]);//andy</span><br></pre></td></tr></table></figure>

<h3 id="节点概述"><a href="#节点概述" class="headerlink" title="节点概述"></a>节点概述</h3><p>网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。</p>
<p>HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以 创建或删除。</p>
<p>一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个 基本属性。</p>
<ul>
<li>元素节点 nodeType 为 1</li>
<li>属性节点 nodeType 为 2</li>
<li>文本节点 nodeType 为 3 (文本节点包含文字、空格、换行等)</li>
</ul>
<h3 id="父节点和兄弟节点和"><a href="#父节点和兄弟节点和" class="headerlink" title="父节点和兄弟节点和"></a>父节点和兄弟节点和</h3><h4 id="1-parentNode"><a href="#1-parentNode" class="headerlink" title="1.parentNode"></a>1.parentNode</h4><p> 获取到的是最近的以及父节点，如果找不到返回null</p>
<h4 id="2-previousSibling"><a href="#2-previousSibling" class="headerlink" title="2.previousSibling"></a>2.previousSibling</h4><p><strong>属性：</strong>表示当前节点的前一个兄弟节点  也可能获取到空白的文本</p>
<p><strong>注意：</strong> previousElementSibling获取前一个兄弟元素，IE8及以下不支持</p>
<h4 id="3-previousElementSibling"><a href="#3-previousElementSibling" class="headerlink" title="3.previousElementSibling"></a>3.previousElementSibling</h4><p>定义：上一个兄弟元素节点</p>
<p><strong>previousElementSibling</strong> 返回当前元素在其父元素的子元素节点中的前一个元素节点，如果该元素已经是第一个元素节点，则返回null,该属性是只读的。</p>
<h4 id="4-nextSibling"><a href="#4-nextSibling" class="headerlink" title="4.nextSibling"></a>4.nextSibling</h4><p><strong>属性：</strong>表示当前节点的后一个兄弟节点</p>
<p>是一个只读属性，返回其父节点的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/childNodes">childNodes</a> 列表中紧跟在其后面的节点，如果指定的节点为最后一个节点，则返回 null</p>
<h4 id="5-nextElementSibling"><a href="#5-nextElementSibling" class="headerlink" title="5.nextElementSibling"></a>5.nextElementSibling</h4><p><strong>属性：表示下一个兄弟元素节点</strong></p>
<h3 id="获取元素节点的子节点"><a href="#获取元素节点的子节点" class="headerlink" title="获取元素节点的子节点"></a>获取元素节点的子节点</h3><h4 id="1-childNodes"><a href="#1-childNodes" class="headerlink" title="1.childNodes"></a>1.childNodes</h4><p><strong>属性：</strong>表示当前节点的所有子节点   childNodes属性会获取包括文本节点在内的所有节点</p>
<p><strong>注意：</strong>在IE8及以下的游览器中，不会将空白文本当成子节点</p>
<p><strong>返回值</strong>：parentNode.childNodes 返回包含指定节点的子节点的集合，该集合为即时更新的集合。</p>
<h4 id="2-firstChild（第一个子节点）"><a href="#2-firstChild（第一个子节点）" class="headerlink" title="2.firstChild（第一个子节点）"></a>2.firstChild（第一个子节点）</h4><p>属性，表示当前节点的第一个子节点（包括空口）</p>
<p>firstChild 返回第一个子节点，找不到则返回null。同样，也是包含所有的节点。</p>
<h4 id="3-lastChild最后一个子节点"><a href="#3-lastChild最后一个子节点" class="headerlink" title="3.lastChild最后一个子节点"></a>3.lastChild最后一个子节点</h4><p>lastChild 返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点。</p>
<h3 id="获取子元素节点"><a href="#获取子元素节点" class="headerlink" title="获取子元素节点"></a>获取子元素节点</h3><h4 id="1-parentNode-children"><a href="#1-parentNode-children" class="headerlink" title="1.parentNode.children"></a>1.parentNode.children</h4><p><strong>parentNode.children</strong> 是一个只读属性，返回所有的子<strong>元素节点</strong>。它只返回子元素节点，其余节点不返 回 （<strong>这个是我们重点掌握的</strong>）。</p>
<p>虽然children 是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用</p>
<p>返回值：返回的是伪数组, 一堆集合，如果要获取里面的元素, 索引获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">      &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;)</span><br><span class="line">var lis = ul.querySelectorAll(&#x27;li&#x27;)</span><br><span class="line">console.log(ul.children)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655632444007-b812da43-4f08-42c2-bb0f-a4e0ac56af99.png" alt="img"></p>
<h4 id="2-firstElementChild"><a href="#2-firstElementChild" class="headerlink" title="2.firstElementChild"></a>2.firstElementChild</h4><p>第一个子元素节点   parentNode.firstElementChild </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取第一个子元素节点</span><br><span class="line">console.log(ul.children[0])</span><br><span class="line"> 3. 实际开发的写法  既没有兼容性问题又返回第一个子元素</span><br><span class="line">console.log(ol.children[0]);</span><br><span class="line"> console.log(ol.firstElementChild);</span><br><span class="line"> console.log(ol.lastElementChild);</span><br></pre></td></tr></table></figure>

<h4 id="3-lastElementChild"><a href="#3-lastElementChild" class="headerlink" title="3.lastElementChild"></a>3.lastElementChild</h4><p>最后一个子元素节点     parentNode.lastElementChild </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> // 获取最后一个子元素节点</span><br><span class="line">console.log(ul.children[ul.children.length - 1])</span><br><span class="line">console.log(ol.children[ol.children.length - 1]);</span><br></pre></td></tr></table></figure>

<h3 id="dom的增删改"><a href="#dom的增删改" class="headerlink" title="dom的增删改"></a>dom的增删改</h3><h4 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h4><p><strong>语法：</strong>创建一个元素节点对象，需要一个标签名作为参数，</p>
<p><strong>返回值：</strong>将会根据标签名创建元素节点对象，并将创建号的对象作为返回值返回。</p>
<p><strong>注意：需要与appendChild配合使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;123&lt;/li&gt;</span><br><span class="line">        &lt;li class=&quot;demo&quot;&gt;ffffffff&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;123&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">      //先获取到父节点：</span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;)</span><br><span class="line">var li = document.createElement(&quot;i&quot;)</span><br><span class="line">li.innerHTML = &#x27;dddddd&#x27;</span><br><span class="line">ul.appenChild(li);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild"></a>appendChild</h4><p><strong>定义：</strong>把新的子节点添加到父节点中</p>
<p><strong>用法：</strong>父节点.appendChild(子节点)；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ul.appendChild(li)</span><br></pre></td></tr></table></figure>

<h4 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild"></a>removeChild</h4><p>node.removeChild(child)  </p>
<p><strong>语法</strong>：父节点.removeChild()</p>
<p>子节点.parentNode.removeChild(子节点)  简便方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;span&gt;</span><br><span class="line">            &lt;button class=&quot;btn&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;kkk&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">    var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">    btn.onclick = function() &#123;</span><br><span class="line">        ul.removeChild(this.parentNode.parentNode)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h4><p>定义：添加节点，从前面添加</p>
<p>语法：.insertBefore(child,指定元素)                                                   </p>
<p>注意：指定元素 一定是node的子元素/子节点， node 表示父节点，child 表示要添加的节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var lis2 = document.createElement(&#x27;li&#x27;);</span><br><span class="line">lis2.innerHTML = &#x27;我事你的滴滴滴&#x27;</span><br><span class="line">ul.insertBefore(lis2,ul.children[0])</span><br><span class="line">ul.insertBefore(lis2,ul.children[ul.children.length - 1])</span><br></pre></td></tr></table></figure>

<h4 id="createTextNode"><a href="#createTextNode" class="headerlink" title="createTextNode"></a>createTextNode</h4><p>创建一个文本节点对象</p>
<p>需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新的节点返回。</p>
<h4 id="replaceChild"><a href="#replaceChild" class="headerlink" title="replaceChild();"></a>replaceChild();</h4><p>可以使用指定的字节点替换已有的子节点。</p>
<p>父节点.replaceChild(新，旧)</p>
<p>cloneNode();</p>
<p>定义：克隆节点</p>
<p>语法：node.cloneNode();</p>
<p>注意：括号里面没有参数的是不复制文本节点的值，有括号的是代表包括标签和里面的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  // 1. 语法</span><br><span class="line">// 克隆节点 : var dupNode = node.cloneNode()</span><br><span class="line">// node.cloneNode()  </span><br><span class="line">// node : 将要被复制, 克隆的节点</span><br><span class="line">// dupNode : 复制后得到的节点  dup : duplicate 复制</span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">var li0 = ul.children[0];</span><br><span class="line">var dup_li0 = li0.cloneNode(true);</span><br><span class="line">console.log(dup_li0);</span><br><span class="line"></span><br><span class="line">//2.传参</span><br><span class="line">//node.cloneNode(true);</span><br><span class="line">//如果传true，深拷贝：表示 不仅克隆节点，节点内的内容也一起克隆（复制标签和里面的内容）</span><br><span class="line">//node.cloneNode();不传参或者传false，浅拷贝，只复制标签，不复制内容</span><br><span class="line">//实际开发用的时候，一般 传true</span><br></pre></td></tr></table></figure>

<h3 id="三种创建元素的方式和区别"><a href="#三种创建元素的方式和区别" class="headerlink" title="三种创建元素的方式和区别"></a>三种创建元素的方式和区别</h3><h4 id="document-write"><a href="#document-write" class="headerlink" title="document.write();"></a>document.write();</h4><p>新建内容会重写整个页面，会造成页面重绘。</p>
<h4 id="document-innerHTML"><a href="#document-innerHTML" class="headerlink" title="document.innerHTML"></a>document.innerHTML</h4><p>可以识别html标签，会替换原来标签里面的内容，同时可以获取里面本身的值，和删除</p>
<h4 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement();"></a>document.createElement();</h4><p>元素末尾添加，不会覆盖原来的内容；</p>
<h4 id="这三个元素的效率："><a href="#这三个元素的效率：" class="headerlink" title="这三个元素的效率："></a>这三个元素的效率：</h4><p>innerHTM拼接效率小于数组拼接的效率；</p>
<h3 id="console-time"><a href="#console-time" class="headerlink" title="console.time();"></a>console.time();</h3><p>记录开始执行的时间：</p>
<h3 id="console-timeEnd"><a href="#console-timeEnd" class="headerlink" title="console.timeEnd();"></a>console.timeEnd();</h3><p>执行结束的时间</p>
<h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table();"></a>console.table();</h3><p>数组和对象以表格的形式在控制台输出；</p>
<h3 id="注册事件的两种方式"><a href="#注册事件的两种方式" class="headerlink" title="注册事件的两种方式"></a>注册事件的两种方式</h3><p>传统注册方式</p>
<p>注意点：会发生事件覆盖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">传统注册事件的方式：</span><br><span class="line">    varbtns = document.querySelectorAll(&#x27;button&#x27;)</span><br><span class="line">       // 1.传统注册事件的方式: </span><br><span class="line">       btns[0].onclick = function () &#123;</span><br><span class="line">        console.log(&quot;ddddd&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  \2. 事件监听的方式注册事件</p>
<p>​       addEventListener(type, listener,[useCapture])</p>
<p>​       type: 事件类型字符串，比如click、mouseover，前面不需要加on；</p>
<p>​       listener: 事件处理函数，事件发生时，会调用该监听函数；</p>
<p>​       useCapture: 可选参数，是布尔值，默认是false，表示事件冒泡。（学习完DOM事件流在进一步学习）；</p>
<p>​        add 添加, Event 事件, Listener 监听器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var btns = document.querySelectorAll(&#x27;button&#x27;)</span><br><span class="line">btns.addEventListener(&#x27;click&#x27;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>定义：就是传递一个参数化的函数，就是将这个函数作为一个参数传到另一个主函数里面，当那一个主函数执行完之后，再执行传进去的作为参数的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//回调函数： 刚开始不执行，后来应为触发了事件在回来执行</span><br><span class="line">   //1.函数的声明方式</span><br><span class="line">   //function 声明</span><br><span class="line">     function fn()&#123;</span><br><span class="line">       console.log(&#x27;ddd&#x27;);</span><br><span class="line">   </span><br><span class="line">     &#125;</span><br><span class="line">     //2.表达式方式：</span><br><span class="line">     var fd = function () &#123;</span><br><span class="line">       console.log(&#x27;ddd&#x27;);</span><br><span class="line">     &#125;</span><br><span class="line">     //注意，fn， fd函数名不要加括号，加括号表示调用执行</span><br><span class="line">     btns[1].addEventListener(&#x27;click&#x27;,fn);</span><br><span class="line">     btns[1].addEventListener(&#x27;click&#x27;,fd);</span><br></pre></td></tr></table></figure>

<h3 id="删除事件，解绑事件"><a href="#删除事件，解绑事件" class="headerlink" title="删除事件，解绑事件"></a>删除事件，解绑事件</h3><p>removeEventListener()</p>
<p>传统注册的事件解绑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var btns = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">     btns.onclick = function () &#123;</span><br><span class="line">         console.log(&#x27;dddd&#x27;);</span><br><span class="line">         第一种；</span><br><span class="line">         btns.disabled = true;</span><br><span class="line">         第二种</span><br><span class="line">         //删除事件，解绑一定要写到函数里面</span><br><span class="line">         btns.onclick = null</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>事件监听的方式：</p>
<p>​        functionfn() {</p>
<p>​            console.log(‘ddd’);</p>
<p>​            btns.removeEventListener(‘click’,fn)</p>
<p>​        }</p>
<p>​        btns.addEventListener(‘click’,fn)</p>
<h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>​    // DOM事件流 : 事件的传播过程.</p>
<p>​    // 事件发生时会在元素节点之间按照特点的顺序传播,这个传播过程就叫DOM事件流</p>
<p>​    // DOM事件流 描述的是 元素从页面接收事件的顺序</p>
<p>​    // DOM事件流的三个阶段</p>
<p>​    // 1. 捕获阶段</p>
<p>​    // 2. 处于目标阶段</p>
<p>​    // 3. 冒泡阶段</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655814080172-8ceb02a0-08c0-4629-a832-729205e70cca.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    var son = document.querySelector(&#x27;.son&#x27;)</span><br><span class="line">    var father = document.querySelector(&#x27;.father&#x27;)</span><br><span class="line"></span><br><span class="line">//默认为，空，false，表示事件冒泡</span><br><span class="line">    son.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">        console.log(&#x27;我是son&#x27;);</span><br><span class="line">    &#125;,true)</span><br><span class="line">    father.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">        console.log(&#x27;father&#x27;);</span><br><span class="line">    &#125;,true)</span><br></pre></td></tr></table></figure>

<h3 id="事件冒泡：从子到父"><a href="#事件冒泡：从子到父" class="headerlink" title="事件冒泡：从子到父"></a>事件冒泡：从子到父</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655814522431-1ab5edc6-b653-42a9-bc4b-31eafed53044.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  //默认为，空，false，表示事件冒泡</span><br><span class="line">  son.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">    console.log(&#x27;我是son&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">father.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">    console.log(&#x27;father&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">body.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">    console.log(&#x27;body&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">html.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">    console.log(&#x27;html&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">    console.log(&#x27;document&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="事件对象："><a href="#事件对象：" class="headerlink" title="事件对象："></a>事件对象：</h3><p>​       什么是事件对象?</p>
<p>​            1.event就是一个事件对象, 写在我们的监听函数的小括号里, 当做形参来看</p>
<p>​            2.事件对象只有有了事件才会存在,它是系统给我们自动创建的</p>
<p>​            3.事件对象是我们事件的一系列相关数据的集合跟事件相关, 比如鼠标点击里面就包含了鼠标的相关信息</p>
<p>​            4.这个事件对象我们可以自己命名,可以简写为e</p>
<p>​            5.兼容写法e = e || window.event</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.querySelector(&#x27;button&#x27;)</span><br><span class="line">btn.addEventListener(&#x27;click&#x27;,function(even)&#123;</span><br><span class="line">    console.log(even.type);//触发类型</span><br><span class="line">    console.log(even.target);//触发事件的对象(元素)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="event-target"><a href="#event-target" class="headerlink" title="event.target"></a>event.target</h4><p>//1.e.target</p>
<p>​        //e.target 指向的是 触发事件的元素</p>
<p>​        //e.target  也就是点击的是那个元素，指向的就是哪个元素</p>
<p>注意点：会随着点击元素的改变而改变，当带点击到绑定的元素时就等于  e.target == this</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;  </span><br><span class="line">&lt;ul/&gt;    </span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;)</span><br><span class="line">    ul.addEventListener(&#x27;click&#x27;,function(event)&#123;</span><br><span class="line">        console.log(event.target);//返回的是触发事件的对象(元素) 点击li，返回的是li</span><br><span class="line">        console.log(this); //指向的是ul，this指向</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="e-currentTarget"><a href="#e-currentTarget" class="headerlink" title="e.currentTarget"></a>e.currentTarget</h4><p>和this一样指向的是当前对象的元素</p>
<h4 id="事件对象阻止默认行为"><a href="#事件对象阻止默认行为" class="headerlink" title="事件对象阻止默认行为"></a>事件对象阻止默认行为</h4><h4 id="even-parrentDefault"><a href="#even-parrentDefault" class="headerlink" title="even.parrentDefault"></a>even.parrentDefault</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 2. 阻止默认行为 </span><br><span class="line">        // e.preventDefault() </span><br><span class="line">        // 比如说 a标签, 点击的时候, href 会跳转 .</span><br><span class="line">        // 比如说, 表单点击会提交</span><br><span class="line">         var btn_a = document.querySelector(&#x27;a&#x27;);</span><br><span class="line">         btn_a.addEventListener(&#x27;click&#x27;,function(event)&#123;</span><br><span class="line">            console.log(event.type);</span><br><span class="line">            //1. 阻止默认行为</span><br><span class="line">            event.preventDefault();</span><br><span class="line">            //2.只阻止默认行为，不会影响后面的代码执行</span><br><span class="line">            console.log(123123);</span><br><span class="line">         &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h3><h4 id="stopPropagation"><a href="#stopPropagation" class="headerlink" title="stopPropagation"></a>stopPropagation</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var father = document.querySelector(&#x27;.father&#x27;);</span><br><span class="line">var son = document.querySelector(&#x27;.son&#x27;);</span><br><span class="line"></span><br><span class="line">// addEventListener的第三个参数是false或者不写，程序处在事件冒泡阶段，</span><br><span class="line">// 从里往外一层一层的找目标</span><br><span class="line">// 先找son  ---- father ---- body ---- html --- document文档</span><br><span class="line">// 也就是我们点击了son 就先执行自己的代码，</span><br><span class="line">// 然后事件冒泡, 被father监听到, 执行father的代码</span><br><span class="line">son.addEventListener(&#x27;click&#x27;,function(event) &#123;</span><br><span class="line">    console.log(&#x27;我是son&#x27;);</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">    //阻止事件冒泡 </span><br><span class="line">    click这个事件，传播到这里之后，不在往上传输了！</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">father.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">    console.log(&#x27;father&#x27;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>​     事件委托原理: 背! 面试题</p>
<p>​        // 不需要给每一个子(元素)节点单独设置事件监听，</p>
<p>​        //应为以前要点击每个li标签绑定点击事件，dom要访问5次</p>
<p>​        // ==&gt;而是利用事件冒泡，将事件监听设置在父节点上，通过父节点来监听子节点的事件.</p>
<h4 id="事件委托的缺点"><a href="#事件委托的缺点" class="headerlink" title="事件委托的缺点"></a>事件委托的缺点</h4><p>应为e.target这个元素会随着鼠标点击的对象来改变所以有的时候需要通过其他的方式来区别开点的问题</p>
<p>如果是不同的标签可以通过nodeName来区分开，</p>
<p>如果是相同的标签可以通过设置类名的方式来区分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 事件委托原理: 背! 面试题</span><br><span class="line">      // 不需要给每一个子(元素)节点单独设置事件监听，</span><br><span class="line"></span><br><span class="line">      //应为以前要点击每个li标签绑定点击事件，dom要访问5次</span><br><span class="line">       ==&gt;而是利用事件冒泡，将事件监听设置在父节点上，通过父节点来监听子节点的事件.</span><br><span class="line">         var lis = document.querySelectorAll(&#x27;li&#x27;);</span><br><span class="line">         for(var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">          lis[i].onclick  = function () &#123;</span><br><span class="line">              console.log(this.innerHTML);</span><br><span class="line">          &#125;         </span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">      // ul.addEventListener(&#x27;click&#x27;,function(event)&#123;</span><br><span class="line">      //     console.log(event.target);</span><br><span class="line">      // &#125;)</span><br><span class="line">     事件委托的优点：  </span><br><span class="line">      1.只操作一次dom,提高程序的性能   (只需要一次绑定)</span><br><span class="line">      不用给每个li绑定了</span><br><span class="line">      // var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">      // ul.addEventListener(&#x27;click&#x27;,function(event)&#123;</span><br><span class="line">      //     console.log(event.target.innerHTML);</span><br><span class="line">      // &#125;);</span><br><span class="line"></span><br><span class="line">      2.动态创建的子元素，也拥有注册的事件(点击)</span><br><span class="line">       var li = document.createElement(&#x27;li&#x27;);</span><br><span class="line">       li.innerHTML = &#x27;我是动态创建的&#x27;;</span><br><span class="line">       ul.appendChild(li);</span><br></pre></td></tr></table></figure>

<h3 id="contextmenu"><a href="#contextmenu" class="headerlink" title="contextmenu"></a>contextmenu</h3><p>禁止使用鼠标右键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 禁用右键菜单  contextmenu </span><br><span class="line">document.addEventListener(&#x27;contextmenu&#x27;,function(e)&#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="selectstart"><a href="#selectstart" class="headerlink" title="selectstart"></a>selectstart</h3><p>禁止选中文字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var p  = document.querySelector(&#x27;p&#x27;);</span><br><span class="line"> p.addEventListener(&#x27;selectstart&#x27;,function(e)&#123;</span><br><span class="line">     e.preventDefault()</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="常用键盘事件："><a href="#常用键盘事件：" class="headerlink" title="常用键盘事件："></a>常用键盘事件：</h3><h4 id="keydown"><a href="#keydown" class="headerlink" title="keydown"></a>keydown</h4><p>按下按键的时候触发，一直按住，会一直触发</p>
<p>识别功能键 ctrl shift 上下左右箭头等</p>
<h4 id="keypress"><a href="#keypress" class="headerlink" title="keypress"></a>keypress</h4><p>按下按键的时候触发</p>
<p>不能识别功能键 ctrl shift 等</p>
<h4 id="keyup"><a href="#keyup" class="headerlink" title="keyup"></a>keyup</h4><p>松开键盘的时候触发</p>
<h2 id="Bom"><a href="#Bom" class="headerlink" title="Bom"></a>Bom</h2><p>browser object model 游览器对象模型，把我们游览器看做一个对象，提供给我们一些方法，操作游览器的功能</p>
<h3 id="window-onload"><a href="#window-onload" class="headerlink" title="window.onload"></a>window.onload</h3><p>我们可以在这里写js </p>
<p>​       对 window -&gt; 注册监听load 事件</p>
<p>​        对 document -&gt; DOMContentLoaded</p>
<p>​       事件，当页面所有内容都加载完成之后，包括js，css图片等，执行内部回调函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  window.addEventListener(&#x27;load&#x27;,function() &#123;</span><br><span class="line">      var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">      btn.addEventListe</span><br><span class="line">info.innerHTML = &#x27;一共&#x27; + arr.length + &#x27;这张照片,这是第&#x27; + index + 1 + &#x27;张&#x27;;ner(&#x27;click&#x27;,function() &#123;</span><br><span class="line">          console.log(&#x27;ddddd&#x27;);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="window-DOMContentLoaded"><a href="#window-DOMContentLoaded" class="headerlink" title="window.DOMContentLoaded"></a>window.DOMContentLoaded</h3><p>/* 2.DOMContentLoaded:  DOM元素加载完成后，执行回调函数，此时css和img还没有加载完成 */</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#x27;DOMContentLoaded&#x27;,function() &#123;</span><br><span class="line">    var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">    btn.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">        console.log(&#x27;DOMContentLoaded&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p>调整游览器窗口大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;resize&#x27;,function() &#123;</span><br><span class="line">              /* 获取当前游览器窗口的宽度  window.innerWith */</span><br><span class="line">              // console.log(div.innerWidth);</span><br><span class="line">              if(window.innerWidth &lt; 600) &#123;</span><br><span class="line">                  div.style.display= &#x27;none&#x27;;</span><br><span class="line"></span><br><span class="line">              &#125;else&#123;</span><br><span class="line">                  div.style.display = &#x27;block&#x27;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="setTimeout-调用函数，延迟时间"><a href="#setTimeout-调用函数，延迟时间" class="headerlink" title="setTimeout(调用函数，延迟时间)"></a>setTimeout(调用函数，延迟时间)</h4><p>只执行一次，以毫秒为单位，省略的话默认为o但是最小延迟时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 第一种 */</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&#x27;dddddd&#x27;);</span><br><span class="line">    &#125;,1000);</span><br><span class="line"></span><br><span class="line">    /* 第二种写函数名的方式 */</span><br><span class="line">    function fn() &#123;</span><br><span class="line">        console.log(&#x27;dddddddddddddddddd&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(fn,5000);</span><br></pre></td></tr></table></figure>

<h4 id="清除定时器window-clearTimeout-timeoutId"><a href="#清除定时器window-clearTimeout-timeoutId" class="headerlink" title="清除定时器window.clearTimeout(timeoutId)"></a>清除定时器window.clearTimeout(timeoutId)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// window可以省略, 传入我们的定时器标记</span><br><span class="line"> var button = document.querySelector(&#x27;button&#x27;);</span><br><span class="line"> var timer1 = setTimeout(function()&#123;</span><br><span class="line">     console.log(&#x27;dddddddddddd&#x27;);</span><br><span class="line"> &#125;,5000)</span><br><span class="line"> </span><br><span class="line">     button.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">     clearInterval(timer1)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h4><p>语法:  window.setInterval(func, delay)</p>
<p>每隔一段延迟时间, 执行一次 func, 只要不清除定时器, 会一直执行.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setInterval(function()&#123;</span><br><span class="line">    console.log(&#x27;ddddddddddddddd&#x27;);</span><br><span class="line">&#125;,5000)</span><br><span class="line"></span><br><span class="line">var vd = function() &#123;</span><br><span class="line">    console.log(&#x27;lalalalala&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">回调函数的方式</span><br><span class="line">setInterval(vd,5000);</span><br></pre></td></tr></table></figure>

<h4 id="清除定时器之clearsetInterval"><a href="#清除定时器之clearsetInterval" class="headerlink" title="清除定时器之clearsetInterval"></a>清除定时器之clearsetInterval</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var timer = setInterval(function() &#123;</span><br><span class="line">                console.log(&#x27;migntain ixiix&#x27;);</span><br><span class="line">            &#125;,1000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stop.addEventListener(&#x27;click&#x27;,function()&#123;</span><br><span class="line">           clearInterval(timer)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><p>​     this指向：this在定义的时候不能确定指向，在执行的时候this才能确定</p>
<p>1.全局作用域中/普通函数调用/定时器里面，this指向 window</p>
<p>1.2 普通函数调用</p>
<p>1.3定时器里面</p>
<p>2.1方法调用中，谁调用谁用这个方法，this指向谁</p>
<p>3.0构造函数中，this指向的是构造函数的实列</p>
<h3 id="BOM游览器对象："><a href="#BOM游览器对象：" class="headerlink" title="BOM游览器对象："></a>BOM游览器对象：</h3><h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><p>代表的是整个游览器的窗口，同时window也是网页中的全局对象</p>
<h4 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h4><p>代表的当前游览器的信息，通过该对象可以来识别不同的游览器</p>
<p>navigator.userAgent</p>
<p>判断游览器的信息，是一个字符串，这个字符串中包含有用来描述游览器信息的内容</p>
<p>不同的游览器会有不同的userAgent</p>
<h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><p>代表当前游览器的地址信息，通过location可以获取地址栏信息，或者操作游览器跳转页面</p>
<p>如果直接将location属性修改为一个完整的路径，或相对路径</p>
<p>则我们页面会直接自动跳转熬该路径，并且会生成相应的历史记录</p>
<p>port</p>
<p>hostname</p>
<p>search</p>
<p>assign()</p>
<p>用来跳转到其他页面，作用和直接修改location一样</p>
<p>reload</p>
<p>用于重新加载当前页面，作用和刷新按钮一样</p>
<p>如果在方法中传递一个true，作文参数，则会强制清空缓存刷新页面</p>
<h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>代表游览器的历史记录，可以通过该对象来操作游览器的历史记录</p>
<p>​         由于隐私的原因，该对象不能获取到具体的历史记录，只能操作游览器向前和向后翻页</p>
<p>​          而且只在刚当次访问时有效</p>
<p>length属性：</p>
<p>可以获取到当次访问的链接数量</p>
<p>back()</p>
<p>可以用来回退到上一个页面</p>
<p>forward()</p>
<p>可以跳转到下一个页面，</p>
<h4 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h4><p>代表用户的屏幕的信息，通过该对象可以获取用户的显示器的相关信息</p>
<p>这些bom对象在游览器中都是作为window对象的属性保存</p>
<h3 id="js是单线程语言"><a href="#js是单线程语言" class="headerlink" title="js是单线程语言"></a>js是单线程语言</h3><p>同一时间只能做一件事（同步），所有的任务顺序都执行。</p>
<h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><h4 id="什么是线程？什么是进程？"><a href="#什么是线程？什么是进程？" class="headerlink" title="什么是线程？什么是进程？"></a>什么是线程？什么是进程？</h4><p>进程是资源分配的最小单位，线程是cpu调度的最小单位。</p>
<p>进程：一个进程就是一个正在运行的程序。（任务管理器）</p>
<p>线程：一个进程内执行着的每个任务就是一个线程。允许应用程序并发执行多个任务的一个机制。</p>
<p>一个进程可以包含多个线程</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p><strong>同步</strong>：同一时间只能做一件事情（同步），所有的任务都顺序执行，上一个任务执行完成才执行。</p>
<p>**异步:**可以同一时间执行多个任务，提高了程序的执行效率（并发执行）</p>
<p>同步任务都在主线程上执行，形成一个执行栈</p>
<h3 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h3><ol>
<li>我们先判断js任务是同步任务还是异步任务，所有的同步任务都放入主线程的执行栈中执行.</li>
<li>异步任务会提交给异步进程处理，比如click事件，setTimeout等，当满足触发条件时，异步进程会将异步任务（回调函数）放入任务队列中</li>
<li>当主线程序里的同步任务（所有的，所有的）执行完成之后，会去任务队列中查看是否有可执行的异步任务，如果有，拿到主线程中执行，执行完毕后，在去任务队列中查找，不断循环这样一个过程。</li>
</ol>
<h3 id="事件循环（event-loop）"><a href="#事件循环（event-loop）" class="headerlink" title="事件循环（event loop）"></a>事件循环（event loop）</h3><p>异步任务：又分为** 宏任务**（macTask）和 <strong>微任务</strong>(microTask) 。</p>
<h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><p>1.整个script代码块</p>
<p>2.setTimeout</p>
<p>3.setInterval</p>
<p>4.setTimediate</p>
<h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><p>\1. promise.then() /promise.catch()</p>
<p>\2. process.nextTick </p>
<p>\3. async await</p>
<p>\4. mutationObserver</p>
<p>//每执行一个宏任务，会清空(执行完成所有的)当前的微任务队列。</p>
<h3 id="offset系列属性"><a href="#offset系列属性" class="headerlink" title="offset系列属性"></a>offset系列属性</h3><p>offset偏移量 可以动态的获取我们元素的位置，大小等。</p>
<h4 id="offsetLeft"><a href="#offsetLeft" class="headerlink" title="offsetLeft"></a>offsetLeft</h4><p>获得元素距离带有根据带有定位父元素的位置, 返回值不带单位</p>
<h4 id="offsetTop"><a href="#offsetTop" class="headerlink" title="offsetTop"></a>offsetTop</h4><p>获得元素距离带有根据带有定位父元素的位置, 返回值不带单位</p>
<h4 id="offsetWidth"><a href="#offsetWidth" class="headerlink" title="offsetWidth"></a>offsetWidth</h4><p>offsetWidth 返回元素的大小, 包含border + padding + width</p>
<h4 id="offsetWidth-1"><a href="#offsetWidth-1" class="headerlink" title="offsetWidth"></a>offsetWidth</h4><p>offsetHeight返回元素的大小, 包含border + padding + width</p>
<h4 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h4><p>offsetParent 返回带有定位的父元素, 如果所有的父级都没有定位,返回body</p>
<h3 id="offsetWidth-与style获取宽高的区别"><a href="#offsetWidth-与style获取宽高的区别" class="headerlink" title="offsetWidth 与style获取宽高的区别"></a>offsetWidth 与style获取宽高的区别</h3><h4 id="style-width"><a href="#style-width" class="headerlink" title="style.width"></a>style.width</h4><ol>
<li>style.width 返回带单位的字符串 </li>
<li>style.width 只能获取行内样式中的width</li>
<li>style.width 获取到的width，不包含padding border</li>
<li>可以读写，可以获取样式，也可以设置样式值（行内的）</li>
</ol>
<h4 id="offsetWith"><a href="#offsetWith" class="headerlink" title="offsetWith"></a>offsetWith</h4><ol>
<li>offsetWidth = width + padding + border</li>
<li>offsetWidth获取的是没有单位的数值number</li>
<li>offsetWidth可以得到任意类型样式的值</li>
<li>只能是获取不能去修改</li>
</ol>
<h3 id="client系列"><a href="#client系列" class="headerlink" title="client系列"></a>client系列</h3><p>返回值是number 不带单位</p>
<h4 id="clientTop-clientLeft"><a href="#clientTop-clientLeft" class="headerlink" title="clientTop,clientLeft"></a>clientTop,clientLeft</h4><p>clientTop ,clientLeft 返回元素的border大小</p>
<h4 id="clientWidth-clientHeight"><a href="#clientWidth-clientHeight" class="headerlink" title="clientWidth ,clientHeight"></a>clientWidth ,clientHeight</h4><p>clientWidth ,clientHeight 返回元素自身的大小， 不包含 border</p>
<p>clientWidth =   width + padding</p>
<h4 id="clientWidth-和-offsetWidth-的-最大区别"><a href="#clientWidth-和-offsetWidth-的-最大区别" class="headerlink" title="clientWidth 和 offsetWidth 的 最大区别"></a>clientWidth 和 offsetWidth 的 最大区别</h4><p>clientWidth 不包含 border  offsetWidth 包含border</p>
<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>立即执行函数 :  不需要调用, 立马执行的函数（也叫自执行函数）</p>
<p> 注意：立即执行函数也可以传入参数前面第一个小括号里面写上形参，</p>
<h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>;(function(){})()</p>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>;(function(){}())</p>
<h4 id="立即执行函数的作用"><a href="#立即执行函数的作用" class="headerlink" title="立即执行函数的作用"></a>立即执行函数的作用</h4><p>创建一个独立的作用域，里面所有的变量都是局部变量</p>
<p>不会对外界的变量有影响，也就是说，不会有命名冲突的情况</p>
<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><p><strong>开发一些js插件 或者库的时候，可以用立即执行函数 包起来。</strong></p>
<h3 id="flexible"><a href="#flexible" class="headerlink" title="flexible"></a>flexible</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// 小括号包含完整的function()&#123;&#125;() 刚讲的第一种写法</span><br><span class="line">(function flexible(window, document) &#123;</span><br><span class="line">    // flexible.js 就是实时监听我们页面的大小,动态修改html根元素的字体大小</span><br><span class="line"></span><br><span class="line">     获取 html 根元素</span><br><span class="line">    var docEl = document.documentElement</span><br><span class="line">    </span><br><span class="line">    // dpr 物理像素比, 是物理像素与逻辑像素的比 (DevicePixelRatio  [ˈreɪʃioʊ])</span><br><span class="line">    // 物理像素: 设备分辨率, 硬件真实存在的像素点</span><br><span class="line">    // 逻辑像素(咱们的css像素)：document.documentElement.clientWidth</span><br><span class="line">    // 可查看 移动端html --&gt; 375 iphone6</span><br><span class="line">    var dpr = window.devicePixelRatio || 1</span><br><span class="line"></span><br><span class="line">     1. adjust body font size  设置我们 body 的字体大小</span><br><span class="line">    function setBodyFontSize() &#123;</span><br><span class="line">        // 如果页面中有body 这个元素 就设置body的字体大小</span><br><span class="line">        if (document.body) &#123;</span><br><span class="line">            document.body.style.fontSize = (12 * dpr) + &#x27;px&#x27;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果页面中没有body 这个元素，则等着 我们页面主要的DOM元素加载完毕再去设置body</span><br><span class="line">            // 的字体大小</span><br><span class="line">            document.addEventListener(&#x27;DOMContentLoaded&#x27;, setBodyFontSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setBodyFontSize();</span><br><span class="line"></span><br><span class="line">     2. set 1rem = viewWidth / 10  设置我们html元素的字体大小, 即设置rem的基本单位像素</span><br><span class="line">    // rem是相对单位，是相对html根元素。</span><br><span class="line">    // 通过它既可以做到只修改根元素就成比例地调整所有字体大小</span><br><span class="line">    function setRemUnit() &#123;</span><br><span class="line">        var rem = docEl.clientWidth / 10</span><br><span class="line">        docEl.style.fontSize = rem + &#x27;px&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setRemUnit()</span><br><span class="line"></span><br><span class="line">     3.当页面尺寸变化时, 重新设置rem</span><br><span class="line">    // reset rem unit on page resize  当我们页面尺寸大小发生变化的时候，要重新设置下rem 的大小</span><br><span class="line">    window.addEventListener(&#x27;resize&#x27;, setRemUnit)</span><br><span class="line">        // pageshow 重新加载页面触发的事件 load事件 看视频</span><br><span class="line">        // pageshow 兼容火狐  load</span><br><span class="line">    window.addEventListener(&#x27;pageshow&#x27;, function(e) &#123;</span><br><span class="line">        // e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要从新计算一下rem 的大小</span><br><span class="line">        if (e.persisted) &#123;</span><br><span class="line">            setRemUnit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">     4.兼容0.5px处理 </span><br><span class="line">    // detect 0.5px supports  有些移动端的浏览器不支持0.5像素的写法</span><br><span class="line">    if (dpr &gt;= 2) &#123;</span><br><span class="line">        // https://zhuanlan.zhihu.com/p/371898337</span><br><span class="line">        var fakeBody = document.createElement(&#x27;body&#x27;)</span><br><span class="line">        var testElement = document.createElement(&#x27;div&#x27;)</span><br><span class="line">        testElement.style.border = &#x27;.5px solid transparent&#x27;</span><br><span class="line">        fakeBody.appendChild(testElement)</span><br><span class="line">        docEl.appendChild(fakeBody)</span><br><span class="line">        if (testElement.offsetHeight === 1) &#123;</span><br><span class="line">            // 真正生效的是hairlines这个样式</span><br><span class="line">            // 无法兼容安卓设备、 iOS 8 以下设备 // 2014</span><br><span class="line">            docEl.classList.add(&#x27;hairlines&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">        docEl.removeChild(fakeBody)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(window, document))</span><br><span class="line"></span><br><span class="line">//flexible作用:  我们可以用flexible 配合rem来做页面自适应.</span><br></pre></td></tr></table></figure>

<h3 id="scroll系列"><a href="#scroll系列" class="headerlink" title="scroll系列"></a>scroll系列</h3><h4 id="scrollHeight"><a href="#scrollHeight" class="headerlink" title="scrollHeight"></a>scrollHeight</h4><p>scrollHeight返回元素内容自身的实际高度, 包含内容超出盒子未显示部分的高度并且包括padding，不包含边框</p>
<h4 id="scrollTop"><a href="#scrollTop" class="headerlink" title="scrollTop"></a>scrollTop</h4><p>scrollTop返回元素被卷去的头部   不能用来监听页面的</p>
<h3 id="window-pageYOffset"><a href="#window-pageYOffset" class="headerlink" title="window.pageYOffset"></a>window.pageYOffset</h3><p>页面被卷去的头部</p>
<h3 id="动画原理："><a href="#动画原理：" class="headerlink" title="动画原理："></a>动画原理：</h3><p>​        动画原理</p>
<p>​        1.获得盒子当前位置  offsetLeft</p>
<p>​        2.让盒子在当前位置加上1个移动距离</p>
<p>​        3.利用定时器,不断重复这个操作, 最后加上一个结束条件.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">var timer = setInterval(function()&#123;</span><br><span class="line">    div.style.left = div.offsetLeft +1 + &#x27;px&#x27;;</span><br><span class="line"></span><br><span class="line">    if(div.offsetLeft &gt;= 130)&#123;</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;,15)</span><br></pre></td></tr></table></figure>

<h3 id="简单动画的封装"><a href="#简单动画的封装" class="headerlink" title="简单动画的封装"></a>简单动画的封装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 封装一个简单的动画函数</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">var span = document.querySelector(&#x27;span&#x27;);</span><br><span class="line"> function animate(obj ,target) &#123; //target代表需要停止目标的位置</span><br><span class="line">    obj.timer = setInterval(function()&#123;   </span><br><span class="line">        if(obj.offsetLeft &gt;= target)&#123;</span><br><span class="line">            clearInterval(this.timer);</span><br><span class="line">        &#125;  </span><br><span class="line">        obj.style.left = obj.offsetLeft + 1 + &#x27;px&#x27;;          </span><br><span class="line">    &#125;,15)          </span><br><span class="line">&#125;</span><br><span class="line">animate(div,130);</span><br></pre></td></tr></table></figure>

<h3 id="缓动画原理"><a href="#缓动画原理" class="headerlink" title="缓动画原理"></a>缓动画原理</h3><p>​        缓动动画函数封装obj目标对象target目标位置</p>
<p>​        思路：</p>
<p>​        1.让盒子每次移动的距离慢慢变小， 速度就会慢慢落下来。</p>
<p>​        2.核心公式：(目标值 - 现在的位置) / 10做为每次移动的距离步长</p>
<p>​        3.停止的条件是： 让当前盒子位置等于目标位置就停止定时器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 速度 = 路程 / 时间</span><br><span class="line">// 时间: 每隔多少ms, 15ms 是一定的.</span><br><span class="line">// 步长公式 :  (目标值 - 现在的位置) / 10   作为步长</span><br><span class="line">var span = document.querySelector(&#x27;span&#x27;);</span><br><span class="line">var button = document.querySelector(&#x27;button&#x27;)</span><br><span class="line">function animate(obj, target) &#123;</span><br><span class="line">    var step = (target - obj.offsetLeft) / 10;</span><br><span class="line">    /* 应为每次点击变得速度都不一样每次点击都会调用则需要清楚以下 */</span><br><span class="line">    clearInterval(obj.timer)</span><br><span class="line">    obj.timer = setInterval(function () &#123;</span><br><span class="line">        if (obj.offsetLeft &gt; = target) &#123;</span><br><span class="line">            clearInterval(obj.timer);</span><br><span class="line">        &#125;</span><br><span class="line">        obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;;</span><br><span class="line">    &#125;, 15)</span><br><span class="line">&#125;</span><br><span class="line">button.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    animate(span, 500);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="缓动画添加回调函数"><a href="#缓动画添加回调函数" class="headerlink" title="缓动画添加回调函数"></a>缓动画添加回调函数</h3><p>​       // 给封装的函数添加回调函数callback(); </p>
<p>​        // 回调函数: 回头再调用的函数, 也就是当满足触发条件, 再调用的函数</p>
<p>​        // 函数也可以作为参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function animate(obj, target,callback) &#123;</span><br><span class="line">                clearInterval(obj.timer)</span><br><span class="line">                obj.timer = setInterval(function()&#123;</span><br><span class="line">                    var step = (target - obj.offsetLeft) / 10</span><br><span class="line">                    step = step &gt; 0 ? Math.ceil(step) : Math.floor(step)</span><br><span class="line">                    /* 当到达指定的位置 */</span><br><span class="line">                    if (obj.offsetLeft == target)&#123;</span><br><span class="line">                        /* 应为每次点击都会被调用,所以需要清楚定时器 */</span><br><span class="line">                        clearInterval(obj.timer);</span><br><span class="line">                        /* 判断这个函数是否存在如果不存在则不调用 */</span><br><span class="line">                        // 普通写法</span><br><span class="line">                        /* if(callback)&#123;</span><br><span class="line">                              callback(); </span><br><span class="line">                        &#125; */</span><br><span class="line">                        callback&amp;&amp;callback(); </span><br><span class="line">                    &#125;</span><br><span class="line">                    obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;</span><br><span class="line">                &#125;, 15)</span><br><span class="line">            &#125;</span><br><span class="line">  var fn = function()&#123;</span><br><span class="line">                span.style.backgroundColor = &#x27;orange&#x27;;</span><br><span class="line">                span.style.width = &#x27;300px&#x27;;</span><br><span class="line">                span.style.height = &#x27;300px&#x27;;</span><br><span class="line">                span.style.transform = &#x27;rotate(3600deg)&#x27;;</span><br><span class="line">                span.style.borderRadius = &#x27;50%&#x27;;</span><br><span class="line">                span.style.transition = &#x27;all 2s&#x27;;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            btn800.addEventListener(&#x27;click&#x27;,function()&#123;</span><br><span class="line">                animate(span,800,fn);</span><br><span class="line">            &#125;)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>手机端手指的触摸是触发</p>
<h4 id="touchmove"><a href="#touchmove" class="headerlink" title="touchmove"></a>touchmove</h4><p>模拟手机按住手机屏幕不放。</p>
<h4 id="touchend"><a href="#touchend" class="headerlink" title="touchend"></a>touchend</h4><p>touchend：手指在dom元素上离开时候触发。按住离开后会触发</p>
<h3 id="触摸事件对象"><a href="#触摸事件对象" class="headerlink" title="触摸事件对象"></a>触摸事件对象</h3><p> 触摸事件对象</p>
<p>​        \1. 获取元素</p>
<p>​        \2. 手指触摸DOM元素事件</p>
<p>​         事件对象：当某个事件触发的时候，和这个事件相关的系列信息集合都放在这个event事件对象里面</p>
<p>回顾：当某个事件触发的时候，和这个事件相关的系列信息集合都放在这个event对象中。</p>
<h4 id="e-touches"><a href="#e-touches" class="headerlink" title="e.touches"></a>e.touches</h4><p>所有正在触摸屏幕的所有手指的列表信息（伪数组）</p>
<h4 id="e-targetTouches"><a href="#e-targetTouches" class="headerlink" title="e.targetTouches"></a>e.targetTouches</h4><p>所有正在触摸当前dom元素的手指列表信息 也是一个伪数组</p>
<h4 id="e-targetTouches-0-pageX"><a href="#e-targetTouches-0-pageX" class="headerlink" title="e.targetTouches[0].pageX"></a>e.targetTouches[0].pageX</h4><p>可以获取手指触摸dom元素时, 手指相对于页面文档的坐标</p>
<h3 id="e-changedTouches"><a href="#e-changedTouches" class="headerlink" title="e.changedTouches"></a>e.changedTouches</h3><p>手指状态发生改变时的手指列表信息</p>
<h3 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h3><h4 id="classList-toggle"><a href="#classList-toggle" class="headerlink" title="classList.toggle();"></a>classList.toggle();</h4><p>通过ClassList.toggle为元素切换类,将它放在点击事件中若检测到没有color类就添加，若检测到有color类就删除</p>
<h4 id="classList-add"><a href="#classList-add" class="headerlink" title="classList.add()"></a>classList.add()</h4><p>通过ClassList.add()向元素添加一个或多个类名;</p>
<h4 id="classList-remove"><a href="#classList-remove" class="headerlink" title="classList.remove()"></a>classList.remove()</h4><p>通过ClassList.remove()删除元素的一个或多个类名;</p>
<h3 id="fastclick插件"><a href="#fastclick插件" class="headerlink" title="fastclick插件"></a>fastclick插件</h3><p>   // 产生300ms延迟的原因</p>
<p>​        // 由于移动端会有双击缩放的这个操作，因此浏览器在click之后要等待300ms，</p>
<p>​        // 看用户有没有下一次点击，也就是这次操作是不是双击。</p>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p> 解决方案一；</p>
<p>​        // <!-- <meta name="viewport" content="user-scalable=no" > --></p>
<p>​        // <!-- user-scalable=no ：禁止用户自由缩放，runoob --></p>
<h3 id="本地存储"><a href="#本地存储" class="headerlink" title="*****本地存储"></a>*****本地存储</h3><h4 id="sessionStorage（存储数据，字符串）"><a href="#sessionStorage（存储数据，字符串）" class="headerlink" title="sessionStorage（存储数据，字符串）"></a>sessionStorage（存储数据，字符串）</h4><p>​    sessionStorage的考点；</p>
<p>​        1.生命周期 ：是关闭当前窗口结束  (也就是关闭了窗口Tab，数据消失)</p>
<p>​        2.数据共享 : 同一个窗口(tab,页面)  下数据是可以共享的。</p>
<p>​        3.存储大小 : sessionStorage  存储大小 5m  localStrorage存储大小也是5m</p>
<p>​        4.方法</p>
<p>​           设置 : sessionStorage.setItem(key,value);</p>
<p>​           获取 : sessionStorage.getItem(key)</p>
<p>​           删除 : sessionStorage.removeItem(key);</p>
<p>​           清空 : sessionStorage.clear();</p>
<p>​        sessionStorage / localStorage : 刷新页面, 数据还是存在浏览器里面的</p>
<h4 id="localStorage（存储数据，字符串）"><a href="#localStorage（存储数据，字符串）" class="headerlink" title="localStorage（存储数据，字符串）"></a>localStorage（存储数据，字符串）</h4><p>​    localStorage的考点</p>
<p>​        1.生命周期  :  永久生效, 除非手动删除, 否则关闭浏览器也会存在</p>
<p>​        2.数据共享  :  可以多窗口(页面)共享 (同一个浏览器可以共享)</p>
<p>​        3.存储大小  : sessionStorage存储大小 5M  localStorage存储大小也是5M</p>
<p>​        4.方法</p>
<p>​           设置 : localStorage.setItem(key, value)</p>
<p>​           获取 : localStorage.getItem(key)</p>
<p>​           删除 : localStorage.removeItem(key) </p>
<p>​           清空 : localStorage.clear()</p>
<p>​        sessionStorage / localStorage : 刷新页面, 数据还是存在浏览器里面的</p>
<h3 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h3><p>  实际开发, 咱们存储的一般是对象或者数组形式(字符串)的数据 ===&gt; JSON格式的字符串</p>
<p> 注意, localStorage/ sessionStorage  存储的是字符串</p>
<h3 id="JSON的两个方法"><a href="#JSON的两个方法" class="headerlink" title="JSON的两个方法"></a>JSON的两个方法</h3><h4 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h4><p> JSON.stringify()  将对象转换成JSON格式的字符串</p>
<h4 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h4><p>JSON.parse()  将JSON格式的字符串转换为对象形式</p>
<p>   当我们想要吧，对象，或者数组， 这样复杂的数据类型存到本地里面，需要转换。</p>
<h3 id="线程和进程-1"><a href="#线程和进程-1" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>CPU一次只能运行一个任务。</p>
<p>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。</p>
<p>线程就好比车间里的工人。一个进程可以包括多个线程。</p>
<p>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</p>
<p>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</p>
<p>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81">“互斥锁”</a>（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</p>
<p>还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</p>
<p>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Semaphore_(programming)">“信号量”</a>（Semaphore），用来保证多个线程不会互相冲突。</p>
<p>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/08/js%E9%AB%98%E7%BA%A7/" rel="prev" title="js高级">
      <i class="fa fa-chevron-left"></i> js高级
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/08/html%E5%92%8Ccss/" rel="next" title="html和css">
      html和css <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#API"><span class="nav-number">1.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#web-API"><span class="nav-number">2.</span> <span class="nav-text">web API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dom"><span class="nav-number"></span> <span class="nav-text">Dom</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">文档模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8A%82%E7%82%B9Node-%E2%80%93%E6%9E%84%E6%88%90html%E6%96%87%E6%A1%A3%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%8D%95%E5%85%83"><span class="nav-number">2.</span> <span class="nav-text">节点Node –构成html文档最基本的单元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">文档节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0"><span class="nav-number">3.</span> <span class="nav-text">获取元素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#getElementById"><span class="nav-number">3.1.</span> <span class="nav-text">getElementById()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%93%E5%B1%95"><span class="nav-number">3.2.</span> <span class="nav-text">拓展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getElementsByTagName"><span class="nav-number">3.3.</span> <span class="nav-text">getElementsByTagName();</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%88%B0id%E4%B8%BAol%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89li%E6%A0%87%E7%AD%BE"><span class="nav-number">3.4.</span> <span class="nav-text">获取到id为ol下的所有li标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E9%80%9A%E8%BF%87tagname-%E8%8E%B7%E5%8F%96%EF%BC%8C%E5%85%88%E5%BE%97%E5%88%B0%E7%9A%84%E6%98%AF%E4%BC%AA%E6%95%B0%E7%BB%84"><span class="nav-number">3.5.</span> <span class="nav-text">如果通过tagname 获取，先得到的是伪数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getElementsByClassName"><span class="nav-number">3.6.</span> <span class="nav-text">getElementsByClassName()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-querySelector"><span class="nav-number">3.7.</span> <span class="nav-text">document.querySelector();</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-querySelectorAll"><span class="nav-number">3.8.</span> <span class="nav-text">document.querySelectorAll();</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%AE%80%E4%BB%8B%E5%86%99%E6%B3%95"><span class="nav-number">3.9.</span> <span class="nav-text">开发中的简介写法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%A4%E4%B8%AA"><span class="nav-number">3.10.</span> <span class="nav-text">特殊的两个</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">4.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-number">4.1.</span> <span class="nav-text">事件三要素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BC%A0%E6%A0%87%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9B%B8%E5%85%B3%E4%BA%8B%E4%BB%B6"><span class="nav-number">4.2.</span> <span class="nav-text">鼠标的一些相关事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clientX%E5%92%8CclientY"><span class="nav-number">4.3.</span> <span class="nav-text">clientX和clientY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pageX-pageY"><span class="nav-number">4.4.</span> <span class="nav-text">pageX,pageY</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%9A"><span class="nav-number">5.</span> <span class="nav-text">事件冒泡：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E5%B9%B6%E6%94%B9%E5%8F%98%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9"><span class="nav-number">6.</span> <span class="nav-text">操作元素并改变元素内容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#innderHmL-%E5%92%8C-innerText%E7%9A%84%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="nav-number">6.1.</span> <span class="nav-text">innderHmL 和 innerText的相同点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#innerText-%E5%92%8C-innderHmL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.2.</span> <span class="nav-text">innerText 和 innderHmL的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="nav-number">7.</span> <span class="nav-text">常见修改属性操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E4%B9%8B%E4%BF%AE%E6%94%B9%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7"><span class="nav-number">8.</span> <span class="nav-text">操作元素之修改样式属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87style%E6%9D%A5%E4%BF%AE%E6%94%B9"><span class="nav-number">8.1.</span> <span class="nav-text">通过style来修改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getComputedStyle"><span class="nav-number">8.2.</span> <span class="nav-text">getComputedStyle()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87className%E6%9D%A5%E4%BF%AE%E6%94%B9%E6%A0%B7%E5%BC%8F"><span class="nav-number">8.3.</span> <span class="nav-text">通过className来修改样式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E4%BB%96%E6%80%9D%E6%83%B3"><span class="nav-number">9.</span> <span class="nav-text">排他思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">10.</span> <span class="nav-text">自定义属性的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="nav-number">10.1.</span> <span class="nav-text">获取元素属性：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="nav-number">10.2.</span> <span class="nav-text">获取元素自定义属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="nav-number">10.3.</span> <span class="nav-text">设置元素属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%85%83%E7%B4%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="nav-number">10.4.</span> <span class="nav-text">设置元素自定义属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dataset%E8%8E%B7%E5%8F%96%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="nav-number">11.</span> <span class="nav-text">dataset获取自定义属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E6%A6%82%E8%BF%B0"><span class="nav-number">12.</span> <span class="nav-text">节点概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%B6%E8%8A%82%E7%82%B9%E5%92%8C%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%E5%92%8C"><span class="nav-number">13.</span> <span class="nav-text">父节点和兄弟节点和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-parentNode"><span class="nav-number">13.1.</span> <span class="nav-text">1.parentNode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-previousSibling"><span class="nav-number">13.2.</span> <span class="nav-text">2.previousSibling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-previousElementSibling"><span class="nav-number">13.3.</span> <span class="nav-text">3.previousElementSibling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-nextSibling"><span class="nav-number">13.4.</span> <span class="nav-text">4.nextSibling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-nextElementSibling"><span class="nav-number">13.5.</span> <span class="nav-text">5.nextElementSibling</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9%E7%9A%84%E5%AD%90%E8%8A%82%E7%82%B9"><span class="nav-number">14.</span> <span class="nav-text">获取元素节点的子节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-childNodes"><span class="nav-number">14.1.</span> <span class="nav-text">1.childNodes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-firstChild%EF%BC%88%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%89"><span class="nav-number">14.2.</span> <span class="nav-text">2.firstChild（第一个子节点）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-lastChild%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9"><span class="nav-number">14.3.</span> <span class="nav-text">3.lastChild最后一个子节点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%90%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9"><span class="nav-number">15.</span> <span class="nav-text">获取子元素节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-parentNode-children"><span class="nav-number">15.1.</span> <span class="nav-text">1.parentNode.children</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-firstElementChild"><span class="nav-number">15.2.</span> <span class="nav-text">2.firstElementChild</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-lastElementChild"><span class="nav-number">15.3.</span> <span class="nav-text">3.lastElementChild</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dom%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9"><span class="nav-number">16.</span> <span class="nav-text">dom的增删改</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#createElement"><span class="nav-number">16.1.</span> <span class="nav-text">createElement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#appendChild"><span class="nav-number">16.2.</span> <span class="nav-text">appendChild</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#removeChild"><span class="nav-number">16.3.</span> <span class="nav-text">removeChild</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#insertBefore"><span class="nav-number">16.4.</span> <span class="nav-text">insertBefore</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#createTextNode"><span class="nav-number">16.5.</span> <span class="nav-text">createTextNode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#replaceChild"><span class="nav-number">16.6.</span> <span class="nav-text">replaceChild();</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">17.</span> <span class="nav-text">三种创建元素的方式和区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#document-write"><span class="nav-number">17.1.</span> <span class="nav-text">document.write();</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-innerHTML"><span class="nav-number">17.2.</span> <span class="nav-text">document.innerHTML</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-createElement"><span class="nav-number">17.3.</span> <span class="nav-text">document.createElement();</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%99%E4%B8%89%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%88%E7%8E%87%EF%BC%9A"><span class="nav-number">17.4.</span> <span class="nav-text">这三个元素的效率：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-time"><span class="nav-number">18.</span> <span class="nav-text">console.time();</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-timeEnd"><span class="nav-number">19.</span> <span class="nav-text">console.timeEnd();</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-table"><span class="nav-number">20.</span> <span class="nav-text">console.table();</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">21.</span> <span class="nav-text">注册事件的两种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">22.</span> <span class="nav-text">回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E4%BA%8B%E4%BB%B6%EF%BC%8C%E8%A7%A3%E7%BB%91%E4%BA%8B%E4%BB%B6"><span class="nav-number">23.</span> <span class="nav-text">删除事件，解绑事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="nav-number">24.</span> <span class="nav-text">DOM事件流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%9A%E4%BB%8E%E5%AD%90%E5%88%B0%E7%88%B6"><span class="nav-number">25.</span> <span class="nav-text">事件冒泡：从子到父</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="nav-number">26.</span> <span class="nav-text">事件对象：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#event-target"><span class="nav-number">26.1.</span> <span class="nav-text">event.target</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#e-currentTarget"><span class="nav-number">26.2.</span> <span class="nav-text">e.currentTarget</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="nav-number">26.3.</span> <span class="nav-text">事件对象阻止默认行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#even-parrentDefault"><span class="nav-number">26.4.</span> <span class="nav-text">even.parrentDefault</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="nav-number">27.</span> <span class="nav-text">阻止事件冒泡</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#stopPropagation"><span class="nav-number">27.1.</span> <span class="nav-text">stopPropagation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-1"><span class="nav-number">28.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="nav-number">29.</span> <span class="nav-text">事件委托</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">29.1.</span> <span class="nav-text">事件委托的缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#contextmenu"><span class="nav-number">30.</span> <span class="nav-text">contextmenu</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#selectstart"><span class="nav-number">31.</span> <span class="nav-text">selectstart</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%EF%BC%9A"><span class="nav-number">32.</span> <span class="nav-text">常用键盘事件：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#keydown"><span class="nav-number">32.1.</span> <span class="nav-text">keydown</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#keypress"><span class="nav-number">32.2.</span> <span class="nav-text">keypress</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#keyup"><span class="nav-number">32.3.</span> <span class="nav-text">keyup</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bom"><span class="nav-number"></span> <span class="nav-text">Bom</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#window-onload"><span class="nav-number">1.</span> <span class="nav-text">window.onload</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#window-DOMContentLoaded"><span class="nav-number">2.</span> <span class="nav-text">window.DOMContentLoaded</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resize"><span class="nav-number">3.</span> <span class="nav-text">resize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#setTimeout-%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4"><span class="nav-number">4.1.</span> <span class="nav-text">setTimeout(调用函数，延迟时间)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E5%AE%9A%E6%97%B6%E5%99%A8window-clearTimeout-timeoutId"><span class="nav-number">4.2.</span> <span class="nav-text">清除定时器window.clearTimeout(timeoutId)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setInterval"><span class="nav-number">4.3.</span> <span class="nav-text">setInterval</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B9%8BclearsetInterval"><span class="nav-number">4.4.</span> <span class="nav-text">清除定时器之clearsetInterval</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">this指向问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BOM%E6%B8%B8%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="nav-number">6.</span> <span class="nav-text">BOM游览器对象：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#window"><span class="nav-number">6.1.</span> <span class="nav-text">window</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Navigator"><span class="nav-number">6.2.</span> <span class="nav-text">Navigator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#location"><span class="nav-number">6.3.</span> <span class="nav-text">location</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#-2"><span class="nav-number">6.4.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#history"><span class="nav-number">6.5.</span> <span class="nav-text">history</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Screen"><span class="nav-number">6.6.</span> <span class="nav-text">Screen</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">7.</span> <span class="nav-text">js是单线程语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="nav-number">8.</span> <span class="nav-text">线程和进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="nav-number">8.1.</span> <span class="nav-text">什么是线程？什么是进程？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-number">9.</span> <span class="nav-text">同步和异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">10.</span> <span class="nav-text">JS执行机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88event-loop%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">事件循环（event loop）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1"><span class="nav-number">11.1.</span> <span class="nav-text">宏任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="nav-number">11.2.</span> <span class="nav-text">微任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#offset%E7%B3%BB%E5%88%97%E5%B1%9E%E6%80%A7"><span class="nav-number">12.</span> <span class="nav-text">offset系列属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#offsetLeft"><span class="nav-number">12.1.</span> <span class="nav-text">offsetLeft</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#offsetTop"><span class="nav-number">12.2.</span> <span class="nav-text">offsetTop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#offsetWidth"><span class="nav-number">12.3.</span> <span class="nav-text">offsetWidth</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#offsetWidth-1"><span class="nav-number">12.4.</span> <span class="nav-text">offsetWidth</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#offsetParent"><span class="nav-number">12.5.</span> <span class="nav-text">offsetParent</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#offsetWidth-%E4%B8%8Estyle%E8%8E%B7%E5%8F%96%E5%AE%BD%E9%AB%98%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">13.</span> <span class="nav-text">offsetWidth 与style获取宽高的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#style-width"><span class="nav-number">13.1.</span> <span class="nav-text">style.width</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#offsetWith"><span class="nav-number">13.2.</span> <span class="nav-text">offsetWith</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#client%E7%B3%BB%E5%88%97"><span class="nav-number">14.</span> <span class="nav-text">client系列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#clientTop-clientLeft"><span class="nav-number">14.1.</span> <span class="nav-text">clientTop,clientLeft</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clientWidth-clientHeight"><span class="nav-number">14.2.</span> <span class="nav-text">clientWidth ,clientHeight</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clientWidth-%E5%92%8C-offsetWidth-%E7%9A%84-%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%88%AB"><span class="nav-number">14.3.</span> <span class="nav-text">clientWidth 和 offsetWidth 的 最大区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="nav-number">15.</span> <span class="nav-text">立即执行函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="nav-number">15.1.</span> <span class="nav-text">方式一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="nav-number">15.2.</span> <span class="nav-text">方式二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">15.3.</span> <span class="nav-text">立即执行函数的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="nav-number">15.4.</span> <span class="nav-text">实际应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flexible"><span class="nav-number">16.</span> <span class="nav-text">flexible</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scroll%E7%B3%BB%E5%88%97"><span class="nav-number">17.</span> <span class="nav-text">scroll系列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#scrollHeight"><span class="nav-number">17.1.</span> <span class="nav-text">scrollHeight</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scrollTop"><span class="nav-number">17.2.</span> <span class="nav-text">scrollTop</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#window-pageYOffset"><span class="nav-number">18.</span> <span class="nav-text">window.pageYOffset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-number">19.</span> <span class="nav-text">动画原理：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%8A%A8%E7%94%BB%E7%9A%84%E5%B0%81%E8%A3%85"><span class="nav-number">20.</span> <span class="nav-text">简单动画的封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86"><span class="nav-number">21.</span> <span class="nav-text">缓动画原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%8A%A8%E7%94%BB%E6%B7%BB%E5%8A%A0%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">22.</span> <span class="nav-text">缓动画添加回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#touch"><span class="nav-number">23.</span> <span class="nav-text">touch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#touchmove"><span class="nav-number">23.1.</span> <span class="nav-text">touchmove</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#touchend"><span class="nav-number">23.2.</span> <span class="nav-text">touchend</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">24.</span> <span class="nav-text">触摸事件对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#e-touches"><span class="nav-number">24.1.</span> <span class="nav-text">e.touches</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#e-targetTouches"><span class="nav-number">24.2.</span> <span class="nav-text">e.targetTouches</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#e-targetTouches-0-pageX"><span class="nav-number">24.3.</span> <span class="nav-text">e.targetTouches[0].pageX</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#e-changedTouches"><span class="nav-number">25.</span> <span class="nav-text">e.changedTouches</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#classList"><span class="nav-number">26.</span> <span class="nav-text">classList</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#classList-toggle"><span class="nav-number">26.1.</span> <span class="nav-text">classList.toggle();</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#classList-add"><span class="nav-number">26.2.</span> <span class="nav-text">classList.add()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#classList-remove"><span class="nav-number">26.3.</span> <span class="nav-text">classList.remove()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fastclick%E6%8F%92%E4%BB%B6"><span class="nav-number">27.</span> <span class="nav-text">fastclick插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A"><span class="nav-number">28.</span> <span class="nav-text">方法二：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="nav-number">29.</span> <span class="nav-text">*****本地存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sessionStorage%EF%BC%88%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="nav-number">29.1.</span> <span class="nav-text">sessionStorage（存储数据，字符串）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#localStorage%EF%BC%88%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="nav-number">29.2.</span> <span class="nav-text">localStorage（存储数据，字符串）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B1%95-1"><span class="nav-number">30.</span> <span class="nav-text">拓展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="nav-number">31.</span> <span class="nav-text">JSON的两个方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON-stringify"><span class="nav-number">31.1.</span> <span class="nav-text">JSON.stringify()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON-parse"><span class="nav-number">31.2.</span> <span class="nav-text">JSON.parse()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B-1"><span class="nav-number">32.</span> <span class="nav-text">线程和进程</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="John Doe"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">59k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
</html>
