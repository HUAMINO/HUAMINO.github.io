<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="石化敏的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="石化敏的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>石化敏的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>




<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">石化敏的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">世界上最美好的事就是在这与你相遇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">4</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/08/html%E5%92%8Ccss/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="石化敏的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/08/html%E5%92%8Ccss/" class="post-title-link" itemprop="url">html和css</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-08 16:27:44 / 修改时间：20:30:56" itemprop="dateCreated datePublished" datetime="2022-07-08T16:27:44+08:00">2022-07-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/html/" itemprop="url" rel="index"><span itemprop="name">html</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.8k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>html和css</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/07/08/html%E5%92%8Ccss/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/08/WebAPI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="石化敏的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/08/WebAPI/" class="post-title-link" itemprop="url">webApi</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-08 16:27:44 / 修改时间：20:32:01" itemprop="dateCreated datePublished" datetime="2022-07-08T16:27:44+08:00">2022-07-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/webApi/" itemprop="url" rel="index"><span itemprop="name">webApi</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>application programming interface 应用程序接口，  api = 接口</p>
<p>接口：在程序里面，接口可以看做是以个方法或者一个函数或者工具</p>
<h3 id="web-API"><a href="#web-API" class="headerlink" title="web API"></a>web API</h3><p>web api = dom + bom</p>
<p>主要针对网页游览器的交互效果 主要是dom和bom</p>
<h2 id="Dom"><a href="#Dom" class="headerlink" title="Dom"></a>Dom</h2><p>文档对象模型  顶级对象就是 document</p>
<p>一个页面就是文档，把页面看做一个对象。</p>
<p>处理页面和网页的内容和结构</p>
<p>dom树</p>
<p>元素:页面上所有的标签都是元素： h1 div span</p>
<p>节点：node页面中所有的内容都是节点；</p>
<h3 id="文档模型"><a href="#文档模型" class="headerlink" title="文档模型"></a>文档模型</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655291423814-aaf56a36-de39-4bc4-a745-55aaab9d901a.png" alt="img"></p>
<h3 id="节点Node-–构成html文档最基本的单元"><a href="#节点Node-–构成html文档最基本的单元" class="headerlink" title="节点Node –构成html文档最基本的单元"></a>节点Node –构成html文档最基本的单元</h3><ul>
<li>文档节点：整个HTML文档  document</li>
<li>元素节点：HTML文档中的html标签</li>
<li>属性节点：元素的属性</li>
<li>文本节点：HTML标签中的文本内容</li>
<li>注释节点：页面中的注释</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655291141489-eaccf24e-d38a-4b97-b819-f7fea165f42c.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655291287386-5cf98408-9d4d-4670-8980-724e0872c435.png" alt="img"></p>
<h4 id="文档节点"><a href="#文档节点" class="headerlink" title="文档节点"></a>文档节点</h4><p>游览器已经为我们提供文档节点，对象这个对象是window属性</p>
<p>可以在页面中直接使用，文档节点代表的是整个网页</p>
<p>document.getElementById(“btn”);</p>
<p>innderHmL修改html内部的代码（）</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><h4 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById()"></a>getElementById()</h4><ul>
<li><strong>定义</strong>： 通过id属性获取一个元素节点对象</li>
</ul>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>console.dir(div) 打印一个对象的所有属性和方法</p>
<h4 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName();"></a>getElementsByTagName();</h4><ul>
<li><strong>定义</strong>：通过标签名获取一组元素节点对象</li>
<li><strong>返回值</strong>：获取所有选中的元素集合，返回的是伪数组，元素集合</li>
<li><strong>伪数组</strong>：有length,有索引你，没有数组的方法</li>
<li>** 注意点**：即使查询到的元素只有一个，也会封装到数组中返回</li>
<li>如果页面上没有这个元素就会返回一个空的伪数组。</li>
</ul>
<p>如果想要打印出每一个li元素，for循环遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">         console.log(lis[i]);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取到id为ol下的所有li标签"><a href="#获取到id为ol下的所有li标签" class="headerlink" title="获取到id为ol下的所有li标签"></a>获取到id为ol下的所有li标签</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol id=&quot;ol&quot;&gt;&lt;li&gt;生僻字&lt;/li&gt; &lt;/ol&gt;</span><br><span class="line">var ol = document.getElementById(&#x27;ol&#x27;);</span><br><span class="line">var list = ol.getElementsByTagName(&#x27;li&#x27;);</span><br><span class="line">console.log(list);</span><br></pre></td></tr></table></figure>

<h4 id="如果通过tagname-获取，先得到的是伪数组"><a href="#如果通过tagname-获取，先得到的是伪数组" class="headerlink" title="如果通过tagname 获取，先得到的是伪数组"></a>如果通过tagname 获取，先得到的是伪数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt;</span><br><span class="line">&lt;ol&gt;&lt;/ol&gt;</span><br><span class="line"></span><br><span class="line">var ols = document.getElementsByTagName(&#x27;ol&#x27;);</span><br><span class="line">var lis_first = ols[0].document.getElementsByTagName(&#x27;li&#x27;)</span><br><span class="line">         console.log(lis_first);</span><br></pre></td></tr></table></figure>

<p>以下是h5新增属性</p>
<h4 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName()"></a>getElementsByClassName()</h4><ul>
<li><strong>定义</strong>：通过name属性获取一组元素节点对象称为一个数组</li>
<li><strong>注意</strong>：类名里面不需要写  . 存在兼容问题ie8不支持</li>
<li><strong>返回值</strong>：返回的是一个伪数组，集合</li>
<li>虽然ie8中没有getElemetByClassName但是可以使用querySelector()</li>
</ul>
<h4 id="document-querySelector"><a href="#document-querySelector" class="headerlink" title="document.querySelector();"></a>document.querySelector();</h4><p><strong>定义</strong>：通过选择器来获取元素</p>
<p><strong>注意</strong>：里面可以写 id ，类，标签，id，类名需要(#  . )</p>
<p><strong>返回值：</strong>返回的是获取到的第一个元素</p>
<p>使用该方法总会返回唯一的一个元素，如果满足条件的有很多个那他只返回第一个                    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var lis4 = document.querySelector(&#x27;#nav li&#x27;)</span><br></pre></td></tr></table></figure>

<h4 id="document-querySelectorAll"><a href="#document-querySelectorAll" class="headerlink" title="document.querySelectorAll();"></a>document.querySelectorAll();</h4><ul>
<li><strong>定义</strong>：返回指定选择器的所有元素对象的集合，一推，伪数组。</li>
<li><strong>注意</strong>：1.获取到的是一堆元素集合2.类名，id都需要加</li>
</ul>
<h4 id="开发中的简介写法"><a href="#开发中的简介写法" class="headerlink" title="开发中的简介写法"></a>开发中的简介写法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = document.querySelector(&#x27;#nav ul  li:last-child&#x27;)</span><br></pre></td></tr></table></figure>

<h4 id="特殊的两个"><a href="#特殊的两个" class="headerlink" title="特殊的两个"></a>特殊的两个</h4><p>获取body元素</p>
<p>document.body</p>
<p>获取html元素</p>
<p>document.html</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><strong>定义：</strong>页面上每个元素都可以触发一些js事件；触发-响应的机制</p>
<p>​            就是文档或游览器窗口中发生的一些特定的相互瞬间</p>
<p><strong>拓展</strong>：javaScript与HTML之间的交互是通过事件实现的</p>
<h4 id="事件三要素"><a href="#事件三要素" class="headerlink" title="事件三要素"></a>事件三要素</h4><p><strong>事件源</strong>：谁，哪个元素</p>
<p><strong>事件类型</strong>：触发了什么事件，点击事件，鼠标移入移出事件，键盘按下，抬起</p>
<p><strong>事件处理程序</strong>：我们要做什么，干嘛</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取事件源</span><br><span class="line">       var btn = document.querySelector(&#x27;#btn&#x27;);</span><br><span class="line">       console.log(btn);</span><br><span class="line">       //2.注册事件，(绑定事件) On当什么什么的时候，click点击</span><br><span class="line">       btn.onclick = function() &#123;</span><br><span class="line">           //3.事件处理程序</span><br><span class="line">         this.btn =====  当前的btn按钮，也就是事件源</span><br><span class="line">           console.log(&#x27;点秋香&#x27;);         </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="鼠标的一些相关事件"><a href="#鼠标的一些相关事件" class="headerlink" title="鼠标的一些相关事件"></a>鼠标的一些相关事件</h4><table>
<thead>
<tr>
<th><strong>鼠标事件</strong></th>
<th><strong>触发条件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>onclick</td>
<td>鼠标点击左键触发</td>
</tr>
<tr>
<td>onmouseover</td>
<td>鼠标进入时触发</td>
</tr>
<tr>
<td>onmouseout</td>
<td>鼠标离开触发</td>
</tr>
<tr>
<td>onfocus</td>
<td>获取鼠标焦点触发</td>
</tr>
<tr>
<td>onblur</td>
<td>失去鼠标焦点触发</td>
</tr>
<tr>
<td>onmousemove</td>
<td>鼠标移动触发</td>
</tr>
<tr>
<td>onmouseup</td>
<td>鼠标弹起触发</td>
</tr>
<tr>
<td>onmousedown</td>
<td>鼠标按下触发</td>
</tr>
</tbody></table>
<h4 id="clientX和clientY"><a href="#clientX和clientY" class="headerlink" title="clientX和clientY"></a>clientX和clientY</h4><p>获取对应的x和y的坐标</p>
<p>注意只能是当前游览器窗口的位移。</p>
<h4 id="pageX-pageY"><a href="#pageX-pageY" class="headerlink" title="pageX,pageY"></a>pageX,pageY</h4><p>是整个游览器的偏移量包括未显示的</p>
<p>注意：这两个属性在ie8中不支持</p>
<h3 id="事件冒泡："><a href="#事件冒泡：" class="headerlink" title="事件冒泡："></a>事件冒泡：</h3><p>所谓的冒泡就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  &lt;div class=&quot;boxd&quot;&gt;</span><br><span class="line">    &lt;span&gt;ddd&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">div.onclick</span><br><span class="line">span.onclick</span><br><span class="line">//当我们点击span时会触发span 也会触发父元素</span><br><span class="line">在开发中大部分的冒泡都是很有用的，如果不希望发生事件冒泡可以通过事件对象来取消冒泡</span><br><span class="line"></span><br><span class="line">e.stopPropagation 阻止事件冒泡</span><br></pre></td></tr></table></figure>

<h3 id="操作元素并改变元素内容"><a href="#操作元素并改变元素内容" class="headerlink" title="操作元素并改变元素内容"></a>操作元素并改变元素内容</h3><h4 id="innderHmL-和-innerText的相同点"><a href="#innderHmL-和-innerText的相同点" class="headerlink" title="innderHmL 和 innerText的相同点"></a>innderHmL 和 innerText的相同点</h4><p>都可以修改文本的内容,同时可以获取里面文本的值</p>
<h4 id="innerText-和-innderHmL的区别"><a href="#innerText-和-innderHmL的区别" class="headerlink" title="innerText 和 innderHmL的区别"></a>innerText 和 innderHmL的区别</h4><p>innerText：不识别htmL标签，非标准，去除空格和换行</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655535362847-85c347d7-4240-4fa1-a28d-b50ae03ebb4d.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655535369805-ccf6fc8c-a8f7-429d-8287-05fdbc29e86f.png" alt="img"></p>
<p>innerHtml：识别htmL标签，标准，保留空格和换行</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655535293682-66006c3b-654a-4c7f-a8e7-cec71a7b7a80.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655535308517-97502e62-3615-480e-a5f3-a9c79fdaf9e2.png" alt="img"></p>
<h3 id="常见修改属性操作"><a href="#常见修改属性操作" class="headerlink" title="常见修改属性操作"></a>常见修改属性操作</h3><p>元素对象.属性</p>
<p>var img = document.querySelector(‘img’);</p>
<p>img.src = ‘images/s.gif’</p>
<h3 id="操作元素之修改样式属性"><a href="#操作元素之修改样式属性" class="headerlink" title="操作元素之修改样式属性"></a>操作元素之修改样式属性</h3><h4 id="通过style来修改"><a href="#通过style来修改" class="headerlink" title="通过style来修改"></a>通过style来修改</h4><p>element.style.样式值 = 值；</p>
<p><strong>注意：复合属性 要改写成驼峰形式    ，修改style 宽高等一定要加上px，字符串。并且url(也需要)</strong></p>
<p>var div = document.querySelector(“div”)</p>
<p>div.style.width = ‘300px’;</p>
<p>div.style.backgroundClor = ‘orange’</p>
<p>div.style.borderRadius= ‘orange’</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">div.onclick = function () &#123;</span><br><span class="line">    div.style.width = &#x27;300px&#x27;</span><br><span class="line">    div.style.backgroundColor = &#x27;orange&#x27; </span><br><span class="line">        // 3. this指向</span><br><span class="line">        console.log(this)</span><br><span class="line">        // this指向的是绑定事件的元素</span><br><span class="line">        this.style.marginTop = &#x27;200px&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getComputedStyle"><a href="#getComputedStyle" class="headerlink" title="getComputedStyle()"></a>getComputedStyle()</h4><p>定义：这个方法是window的方法，可以直接使用</p>
<p>需要两个参数：</p>
<p>第一个：要获取样式的元素</p>
<p>第二个：可以传递一个伪元素，一般都传null</p>
<h4 id="通过className来修改样式"><a href="#通过className来修改样式" class="headerlink" title="通过className来修改样式"></a>通过className来修改样式</h4><p>**className 会覆盖原本自身带的类名  **</p>
<p>可以通过来写多个类名来实现   this.className = ‘first change’</p>
<p><strong>注意：适合多个样式都要修改的时候</strong></p>
<p><strong>可以this.className = ‘’</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.first &#123;</span><br><span class="line">&#125;</span><br><span class="line">this.className = &#x27;first&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="排他思想"><a href="#排他思想" class="headerlink" title="排他思想"></a>排他思想</h3><p>干掉所有的，留下自己的。</p>
<p><strong>使用地方</strong>：如果有相同的一组元素，我们要给某一个元素设置某种样式，就可以用到排他思想</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//1. 获取所有按钮元素</span><br><span class="line">       var btns = document.getElementsByTagName(&#x27;button&#x27;);</span><br><span class="line">       // btns得到的是伪数组  里面的每一个元素 btns[i]</span><br><span class="line">       for (var i = 0; i &lt; btns.length; i++) &#123;</span><br><span class="line">   //应为这些btns已经在数组里面了当你点击网页上的按钮时,就已经获得了这个元素i</span><br><span class="line">           btns[i].onclick = function() &#123;</span><br><span class="line">               //(1) 我们先把所有的按钮背景颜色去掉  干掉所有人</span><br><span class="line">               for (var i = 0; i &lt; btns.length; i++) &#123;</span><br><span class="line">                   btns[i].style.backgroundColor = &#x27;&#x27;;</span><br><span class="line">               &#125;</span><br><span class="line">               //(2) 然后才让当前的元素背景颜色为pink 留下我自己</span><br><span class="line">               this.style.backgroundColor = &#x27;pink&#x27;;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：this.style.backgroundColor = ‘pink’  不能写成 btns[i].style.backgroundColor</strong></p>
<p><strong>应为外面的for循环已经跑完，所以i已经变成了5 如果是btns[i] 就一直是这个undefined;</strong></p>
<h3 id="自定义属性的操作"><a href="#自定义属性的操作" class="headerlink" title="自定义属性的操作"></a>自定义属性的操作</h3><h4 id="获取元素属性："><a href="#获取元素属性：" class="headerlink" title="获取元素属性："></a>获取元素属性：</h4><p><strong>语法</strong>：element.属性     </p>
<p><strong>注意</strong>：只能是元素本身的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot; index=&quot;1&quot; person = &quot;张三&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;</span><br><span class="line">console.log(div.id); // 1</span><br><span class="line">console.log(div.className);  // nav</span><br><span class="line"> 属性不能使用 element.属性</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="获取元素自定义属性"><a href="#获取元素自定义属性" class="headerlink" title="获取元素自定义属性"></a>获取元素自定义属性</h4><p><strong>语法****：</strong>getAttribute(‘属性名’)  </p>
<p><strong>注意：</strong> 可以同时获取元素本身属性和自定义属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot; index=&quot;1&quot; person = &quot;张三&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;</span><br><span class="line">console.log(div.getAttribute(&#x27;index&#x27;));</span><br><span class="line">console.log(div.getAttribute(&#x27;id&#x27;));</span><br><span class="line">console.log(div.getAttribute(&#x27;class&#x27;));</span><br><span class="line">console.log(div.getAttribute(&#x27;person&#x27;));</span><br></pre></td></tr></table></figure>

<h4 id="设置元素属性"><a href="#设置元素属性" class="headerlink" title="设置元素属性"></a>设置元素属性</h4><p><strong>语法</strong>：element.属性     =  ‘值’；</p>
<p><strong>注意</strong>：只能是元素本身的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot; index=&quot;1&quot; person = &quot;张三&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;</span><br><span class="line">div.id = &#x27;2&#x27;;</span><br><span class="line">div.className = &#x27;ddd&#x27;</span><br><span class="line">console.log(div.id)</span><br></pre></td></tr></table></figure>

<h4 id="设置元素自定义属性"><a href="#设置元素自定义属性" class="headerlink" title="设置元素自定义属性"></a>设置元素自定义属性</h4><p><strong>语法</strong>：element.setAttribute(‘属性名’,’值’)  </p>
<p><strong>注意：</strong> 可以同时获取元素本身属性和自定义属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot; index=&quot;1&quot; person = &quot;张三&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;</span><br><span class="line">div.setAttribute(&#x27;id&#x27;,&#x27;3&#x27;)</span><br><span class="line">console.log(div.id);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="dataset获取自定义属性"><a href="#dataset获取自定义属性" class="headerlink" title="dataset获取自定义属性"></a>dataset获取自定义属性</h3><p> <strong>定义</strong>：h5新增的获取自定义属性的方法 它只能获取data-开头的</p>
<p>** 说明：** dataset 是一个集合里面存放了所有以data开头的自定义属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;</span><br><span class="line">console.log(div.dataset.index); //2</span><br><span class="line">console.log(div.dataset[&#x27;index&#x27;]);</span><br><span class="line">// 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法</span><br><span class="line">console.log(div.dataset.listName);//andy</span><br><span class="line">console.log(div.dataset[&#x27;listName&#x27;]);//andy</span><br></pre></td></tr></table></figure>

<h3 id="节点概述"><a href="#节点概述" class="headerlink" title="节点概述"></a>节点概述</h3><p>网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。</p>
<p>HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以 创建或删除。</p>
<p>一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个 基本属性。</p>
<ul>
<li>元素节点 nodeType 为 1</li>
<li>属性节点 nodeType 为 2</li>
<li>文本节点 nodeType 为 3 (文本节点包含文字、空格、换行等)</li>
</ul>
<h3 id="父节点和兄弟节点和"><a href="#父节点和兄弟节点和" class="headerlink" title="父节点和兄弟节点和"></a>父节点和兄弟节点和</h3><h4 id="1-parentNode"><a href="#1-parentNode" class="headerlink" title="1.parentNode"></a>1.parentNode</h4><p> 获取到的是最近的以及父节点，如果找不到返回null</p>
<h4 id="2-previousSibling"><a href="#2-previousSibling" class="headerlink" title="2.previousSibling"></a>2.previousSibling</h4><p><strong>属性：</strong>表示当前节点的前一个兄弟节点  也可能获取到空白的文本</p>
<p><strong>注意：</strong> previousElementSibling获取前一个兄弟元素，IE8及以下不支持</p>
<h4 id="3-previousElementSibling"><a href="#3-previousElementSibling" class="headerlink" title="3.previousElementSibling"></a>3.previousElementSibling</h4><p>定义：上一个兄弟元素节点</p>
<p><strong>previousElementSibling</strong> 返回当前元素在其父元素的子元素节点中的前一个元素节点，如果该元素已经是第一个元素节点，则返回null,该属性是只读的。</p>
<h4 id="4-nextSibling"><a href="#4-nextSibling" class="headerlink" title="4.nextSibling"></a>4.nextSibling</h4><p><strong>属性：</strong>表示当前节点的后一个兄弟节点</p>
<p>是一个只读属性，返回其父节点的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/childNodes">childNodes</a> 列表中紧跟在其后面的节点，如果指定的节点为最后一个节点，则返回 null</p>
<h4 id="5-nextElementSibling"><a href="#5-nextElementSibling" class="headerlink" title="5.nextElementSibling"></a>5.nextElementSibling</h4><p><strong>属性：表示下一个兄弟元素节点</strong></p>
<h3 id="获取元素节点的子节点"><a href="#获取元素节点的子节点" class="headerlink" title="获取元素节点的子节点"></a>获取元素节点的子节点</h3><h4 id="1-childNodes"><a href="#1-childNodes" class="headerlink" title="1.childNodes"></a>1.childNodes</h4><p><strong>属性：</strong>表示当前节点的所有子节点   childNodes属性会获取包括文本节点在内的所有节点</p>
<p><strong>注意：</strong>在IE8及以下的游览器中，不会将空白文本当成子节点</p>
<p><strong>返回值</strong>：parentNode.childNodes 返回包含指定节点的子节点的集合，该集合为即时更新的集合。</p>
<h4 id="2-firstChild（第一个子节点）"><a href="#2-firstChild（第一个子节点）" class="headerlink" title="2.firstChild（第一个子节点）"></a>2.firstChild（第一个子节点）</h4><p>属性，表示当前节点的第一个子节点（包括空口）</p>
<p>firstChild 返回第一个子节点，找不到则返回null。同样，也是包含所有的节点。</p>
<h4 id="3-lastChild最后一个子节点"><a href="#3-lastChild最后一个子节点" class="headerlink" title="3.lastChild最后一个子节点"></a>3.lastChild最后一个子节点</h4><p>lastChild 返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点。</p>
<h3 id="获取子元素节点"><a href="#获取子元素节点" class="headerlink" title="获取子元素节点"></a>获取子元素节点</h3><h4 id="1-parentNode-children"><a href="#1-parentNode-children" class="headerlink" title="1.parentNode.children"></a>1.parentNode.children</h4><p><strong>parentNode.children</strong> 是一个只读属性，返回所有的子<strong>元素节点</strong>。它只返回子元素节点，其余节点不返 回 （<strong>这个是我们重点掌握的</strong>）。</p>
<p>虽然children 是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用</p>
<p>返回值：返回的是伪数组, 一堆集合，如果要获取里面的元素, 索引获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">      &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;)</span><br><span class="line">var lis = ul.querySelectorAll(&#x27;li&#x27;)</span><br><span class="line">console.log(ul.children)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655632444007-b812da43-4f08-42c2-bb0f-a4e0ac56af99.png" alt="img"></p>
<h4 id="2-firstElementChild"><a href="#2-firstElementChild" class="headerlink" title="2.firstElementChild"></a>2.firstElementChild</h4><p>第一个子元素节点   parentNode.firstElementChild </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取第一个子元素节点</span><br><span class="line">console.log(ul.children[0])</span><br><span class="line"> 3. 实际开发的写法  既没有兼容性问题又返回第一个子元素</span><br><span class="line">console.log(ol.children[0]);</span><br><span class="line"> console.log(ol.firstElementChild);</span><br><span class="line"> console.log(ol.lastElementChild);</span><br></pre></td></tr></table></figure>

<h4 id="3-lastElementChild"><a href="#3-lastElementChild" class="headerlink" title="3.lastElementChild"></a>3.lastElementChild</h4><p>最后一个子元素节点     parentNode.lastElementChild </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> // 获取最后一个子元素节点</span><br><span class="line">console.log(ul.children[ul.children.length - 1])</span><br><span class="line">console.log(ol.children[ol.children.length - 1]);</span><br></pre></td></tr></table></figure>

<h3 id="dom的增删改"><a href="#dom的增删改" class="headerlink" title="dom的增删改"></a>dom的增删改</h3><h4 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h4><p><strong>语法：</strong>创建一个元素节点对象，需要一个标签名作为参数，</p>
<p><strong>返回值：</strong>将会根据标签名创建元素节点对象，并将创建号的对象作为返回值返回。</p>
<p><strong>注意：需要与appendChild配合使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;123&lt;/li&gt;</span><br><span class="line">        &lt;li class=&quot;demo&quot;&gt;ffffffff&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;123&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">      //先获取到父节点：</span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;)</span><br><span class="line">var li = document.createElement(&quot;i&quot;)</span><br><span class="line">li.innerHTML = &#x27;dddddd&#x27;</span><br><span class="line">ul.appenChild(li);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild"></a>appendChild</h4><p><strong>定义：</strong>把新的子节点添加到父节点中</p>
<p><strong>用法：</strong>父节点.appendChild(子节点)；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ul.appendChild(li)</span><br></pre></td></tr></table></figure>

<h4 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild"></a>removeChild</h4><p>node.removeChild(child)  </p>
<p><strong>语法</strong>：父节点.removeChild()</p>
<p>子节点.parentNode.removeChild(子节点)  简便方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;span&gt;</span><br><span class="line">            &lt;button class=&quot;btn&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;kkk&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">    var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">    btn.onclick = function() &#123;</span><br><span class="line">        ul.removeChild(this.parentNode.parentNode)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h4><p>定义：添加节点，从前面添加</p>
<p>语法：.insertBefore(child,指定元素)                                                   </p>
<p>注意：指定元素 一定是node的子元素/子节点， node 表示父节点，child 表示要添加的节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var lis2 = document.createElement(&#x27;li&#x27;);</span><br><span class="line">lis2.innerHTML = &#x27;我事你的滴滴滴&#x27;</span><br><span class="line">ul.insertBefore(lis2,ul.children[0])</span><br><span class="line">ul.insertBefore(lis2,ul.children[ul.children.length - 1])</span><br></pre></td></tr></table></figure>

<h4 id="createTextNode"><a href="#createTextNode" class="headerlink" title="createTextNode"></a>createTextNode</h4><p>创建一个文本节点对象</p>
<p>需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新的节点返回。</p>
<h4 id="replaceChild"><a href="#replaceChild" class="headerlink" title="replaceChild();"></a>replaceChild();</h4><p>可以使用指定的字节点替换已有的子节点。</p>
<p>父节点.replaceChild(新，旧)</p>
<p>cloneNode();</p>
<p>定义：克隆节点</p>
<p>语法：node.cloneNode();</p>
<p>注意：括号里面没有参数的是不复制文本节点的值，有括号的是代表包括标签和里面的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  // 1. 语法</span><br><span class="line">// 克隆节点 : var dupNode = node.cloneNode()</span><br><span class="line">// node.cloneNode()  </span><br><span class="line">// node : 将要被复制, 克隆的节点</span><br><span class="line">// dupNode : 复制后得到的节点  dup : duplicate 复制</span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">var li0 = ul.children[0];</span><br><span class="line">var dup_li0 = li0.cloneNode(true);</span><br><span class="line">console.log(dup_li0);</span><br><span class="line"></span><br><span class="line">//2.传参</span><br><span class="line">//node.cloneNode(true);</span><br><span class="line">//如果传true，深拷贝：表示 不仅克隆节点，节点内的内容也一起克隆（复制标签和里面的内容）</span><br><span class="line">//node.cloneNode();不传参或者传false，浅拷贝，只复制标签，不复制内容</span><br><span class="line">//实际开发用的时候，一般 传true</span><br></pre></td></tr></table></figure>

<h3 id="三种创建元素的方式和区别"><a href="#三种创建元素的方式和区别" class="headerlink" title="三种创建元素的方式和区别"></a>三种创建元素的方式和区别</h3><h4 id="document-write"><a href="#document-write" class="headerlink" title="document.write();"></a>document.write();</h4><p>新建内容会重写整个页面，会造成页面重绘。</p>
<h4 id="document-innerHTML"><a href="#document-innerHTML" class="headerlink" title="document.innerHTML"></a>document.innerHTML</h4><p>可以识别html标签，会替换原来标签里面的内容，同时可以获取里面本身的值，和删除</p>
<h4 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement();"></a>document.createElement();</h4><p>元素末尾添加，不会覆盖原来的内容；</p>
<h4 id="这三个元素的效率："><a href="#这三个元素的效率：" class="headerlink" title="这三个元素的效率："></a>这三个元素的效率：</h4><p>innerHTM拼接效率小于数组拼接的效率；</p>
<h3 id="console-time"><a href="#console-time" class="headerlink" title="console.time();"></a>console.time();</h3><p>记录开始执行的时间：</p>
<h3 id="console-timeEnd"><a href="#console-timeEnd" class="headerlink" title="console.timeEnd();"></a>console.timeEnd();</h3><p>执行结束的时间</p>
<h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table();"></a>console.table();</h3><p>数组和对象以表格的形式在控制台输出；</p>
<h3 id="注册事件的两种方式"><a href="#注册事件的两种方式" class="headerlink" title="注册事件的两种方式"></a>注册事件的两种方式</h3><p>传统注册方式</p>
<p>注意点：会发生事件覆盖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">传统注册事件的方式：</span><br><span class="line">    varbtns = document.querySelectorAll(&#x27;button&#x27;)</span><br><span class="line">       // 1.传统注册事件的方式: </span><br><span class="line">       btns[0].onclick = function () &#123;</span><br><span class="line">        console.log(&quot;ddddd&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  \2. 事件监听的方式注册事件</p>
<p>​       addEventListener(type, listener,[useCapture])</p>
<p>​       type: 事件类型字符串，比如click、mouseover，前面不需要加on；</p>
<p>​       listener: 事件处理函数，事件发生时，会调用该监听函数；</p>
<p>​       useCapture: 可选参数，是布尔值，默认是false，表示事件冒泡。（学习完DOM事件流在进一步学习）；</p>
<p>​        add 添加, Event 事件, Listener 监听器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var btns = document.querySelectorAll(&#x27;button&#x27;)</span><br><span class="line">btns.addEventListener(&#x27;click&#x27;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>定义：就是传递一个参数化的函数，就是将这个函数作为一个参数传到另一个主函数里面，当那一个主函数执行完之后，再执行传进去的作为参数的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//回调函数： 刚开始不执行，后来应为触发了事件在回来执行</span><br><span class="line">   //1.函数的声明方式</span><br><span class="line">   //function 声明</span><br><span class="line">     function fn()&#123;</span><br><span class="line">       console.log(&#x27;ddd&#x27;);</span><br><span class="line">   </span><br><span class="line">     &#125;</span><br><span class="line">     //2.表达式方式：</span><br><span class="line">     var fd = function () &#123;</span><br><span class="line">       console.log(&#x27;ddd&#x27;);</span><br><span class="line">     &#125;</span><br><span class="line">     //注意，fn， fd函数名不要加括号，加括号表示调用执行</span><br><span class="line">     btns[1].addEventListener(&#x27;click&#x27;,fn);</span><br><span class="line">     btns[1].addEventListener(&#x27;click&#x27;,fd);</span><br></pre></td></tr></table></figure>

<h3 id="删除事件，解绑事件"><a href="#删除事件，解绑事件" class="headerlink" title="删除事件，解绑事件"></a>删除事件，解绑事件</h3><p>removeEventListener()</p>
<p>传统注册的事件解绑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var btns = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">     btns.onclick = function () &#123;</span><br><span class="line">         console.log(&#x27;dddd&#x27;);</span><br><span class="line">         第一种；</span><br><span class="line">         btns.disabled = true;</span><br><span class="line">         第二种</span><br><span class="line">         //删除事件，解绑一定要写到函数里面</span><br><span class="line">         btns.onclick = null</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>事件监听的方式：</p>
<p>​        functionfn() {</p>
<p>​            console.log(‘ddd’);</p>
<p>​            btns.removeEventListener(‘click’,fn)</p>
<p>​        }</p>
<p>​        btns.addEventListener(‘click’,fn)</p>
<h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>​    // DOM事件流 : 事件的传播过程.</p>
<p>​    // 事件发生时会在元素节点之间按照特点的顺序传播,这个传播过程就叫DOM事件流</p>
<p>​    // DOM事件流 描述的是 元素从页面接收事件的顺序</p>
<p>​    // DOM事件流的三个阶段</p>
<p>​    // 1. 捕获阶段</p>
<p>​    // 2. 处于目标阶段</p>
<p>​    // 3. 冒泡阶段</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655814080172-8ceb02a0-08c0-4629-a832-729205e70cca.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    var son = document.querySelector(&#x27;.son&#x27;)</span><br><span class="line">    var father = document.querySelector(&#x27;.father&#x27;)</span><br><span class="line"></span><br><span class="line">//默认为，空，false，表示事件冒泡</span><br><span class="line">    son.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">        console.log(&#x27;我是son&#x27;);</span><br><span class="line">    &#125;,true)</span><br><span class="line">    father.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">        console.log(&#x27;father&#x27;);</span><br><span class="line">    &#125;,true)</span><br></pre></td></tr></table></figure>

<h3 id="事件冒泡：从子到父"><a href="#事件冒泡：从子到父" class="headerlink" title="事件冒泡：从子到父"></a>事件冒泡：从子到父</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655814522431-1ab5edc6-b653-42a9-bc4b-31eafed53044.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  //默认为，空，false，表示事件冒泡</span><br><span class="line">  son.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">    console.log(&#x27;我是son&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">father.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">    console.log(&#x27;father&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">body.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">    console.log(&#x27;body&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">html.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">    console.log(&#x27;html&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">    console.log(&#x27;document&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="事件对象："><a href="#事件对象：" class="headerlink" title="事件对象："></a>事件对象：</h3><p>​       什么是事件对象?</p>
<p>​            1.event就是一个事件对象, 写在我们的监听函数的小括号里, 当做形参来看</p>
<p>​            2.事件对象只有有了事件才会存在,它是系统给我们自动创建的</p>
<p>​            3.事件对象是我们事件的一系列相关数据的集合跟事件相关, 比如鼠标点击里面就包含了鼠标的相关信息</p>
<p>​            4.这个事件对象我们可以自己命名,可以简写为e</p>
<p>​            5.兼容写法e = e || window.event</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.querySelector(&#x27;button&#x27;)</span><br><span class="line">btn.addEventListener(&#x27;click&#x27;,function(even)&#123;</span><br><span class="line">    console.log(even.type);//触发类型</span><br><span class="line">    console.log(even.target);//触发事件的对象(元素)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="event-target"><a href="#event-target" class="headerlink" title="event.target"></a>event.target</h4><p>//1.e.target</p>
<p>​        //e.target 指向的是 触发事件的元素</p>
<p>​        //e.target  也就是点击的是那个元素，指向的就是哪个元素</p>
<p>注意点：会随着点击元素的改变而改变，当带点击到绑定的元素时就等于  e.target == this</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;  </span><br><span class="line">&lt;ul/&gt;    </span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;)</span><br><span class="line">    ul.addEventListener(&#x27;click&#x27;,function(event)&#123;</span><br><span class="line">        console.log(event.target);//返回的是触发事件的对象(元素) 点击li，返回的是li</span><br><span class="line">        console.log(this); //指向的是ul，this指向</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="e-currentTarget"><a href="#e-currentTarget" class="headerlink" title="e.currentTarget"></a>e.currentTarget</h4><p>和this一样指向的是当前对象的元素</p>
<h4 id="事件对象阻止默认行为"><a href="#事件对象阻止默认行为" class="headerlink" title="事件对象阻止默认行为"></a>事件对象阻止默认行为</h4><h4 id="even-parrentDefault"><a href="#even-parrentDefault" class="headerlink" title="even.parrentDefault"></a>even.parrentDefault</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 2. 阻止默认行为 </span><br><span class="line">        // e.preventDefault() </span><br><span class="line">        // 比如说 a标签, 点击的时候, href 会跳转 .</span><br><span class="line">        // 比如说, 表单点击会提交</span><br><span class="line">         var btn_a = document.querySelector(&#x27;a&#x27;);</span><br><span class="line">         btn_a.addEventListener(&#x27;click&#x27;,function(event)&#123;</span><br><span class="line">            console.log(event.type);</span><br><span class="line">            //1. 阻止默认行为</span><br><span class="line">            event.preventDefault();</span><br><span class="line">            //2.只阻止默认行为，不会影响后面的代码执行</span><br><span class="line">            console.log(123123);</span><br><span class="line">         &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h3><h4 id="stopPropagation"><a href="#stopPropagation" class="headerlink" title="stopPropagation"></a>stopPropagation</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var father = document.querySelector(&#x27;.father&#x27;);</span><br><span class="line">var son = document.querySelector(&#x27;.son&#x27;);</span><br><span class="line"></span><br><span class="line">// addEventListener的第三个参数是false或者不写，程序处在事件冒泡阶段，</span><br><span class="line">// 从里往外一层一层的找目标</span><br><span class="line">// 先找son  ---- father ---- body ---- html --- document文档</span><br><span class="line">// 也就是我们点击了son 就先执行自己的代码，</span><br><span class="line">// 然后事件冒泡, 被father监听到, 执行father的代码</span><br><span class="line">son.addEventListener(&#x27;click&#x27;,function(event) &#123;</span><br><span class="line">    console.log(&#x27;我是son&#x27;);</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">    //阻止事件冒泡 </span><br><span class="line">    click这个事件，传播到这里之后，不在往上传输了！</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">father.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">    console.log(&#x27;father&#x27;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>​     事件委托原理: 背! 面试题</p>
<p>​        // 不需要给每一个子(元素)节点单独设置事件监听，</p>
<p>​        //应为以前要点击每个li标签绑定点击事件，dom要访问5次</p>
<p>​        // ==&gt;而是利用事件冒泡，将事件监听设置在父节点上，通过父节点来监听子节点的事件.</p>
<h4 id="事件委托的缺点"><a href="#事件委托的缺点" class="headerlink" title="事件委托的缺点"></a>事件委托的缺点</h4><p>应为e.target这个元素会随着鼠标点击的对象来改变所以有的时候需要通过其他的方式来区别开点的问题</p>
<p>如果是不同的标签可以通过nodeName来区分开，</p>
<p>如果是相同的标签可以通过设置类名的方式来区分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 事件委托原理: 背! 面试题</span><br><span class="line">      // 不需要给每一个子(元素)节点单独设置事件监听，</span><br><span class="line"></span><br><span class="line">      //应为以前要点击每个li标签绑定点击事件，dom要访问5次</span><br><span class="line">       ==&gt;而是利用事件冒泡，将事件监听设置在父节点上，通过父节点来监听子节点的事件.</span><br><span class="line">         var lis = document.querySelectorAll(&#x27;li&#x27;);</span><br><span class="line">         for(var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">          lis[i].onclick  = function () &#123;</span><br><span class="line">              console.log(this.innerHTML);</span><br><span class="line">          &#125;         </span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">      // ul.addEventListener(&#x27;click&#x27;,function(event)&#123;</span><br><span class="line">      //     console.log(event.target);</span><br><span class="line">      // &#125;)</span><br><span class="line">     事件委托的优点：  </span><br><span class="line">      1.只操作一次dom,提高程序的性能   (只需要一次绑定)</span><br><span class="line">      不用给每个li绑定了</span><br><span class="line">      // var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">      // ul.addEventListener(&#x27;click&#x27;,function(event)&#123;</span><br><span class="line">      //     console.log(event.target.innerHTML);</span><br><span class="line">      // &#125;);</span><br><span class="line"></span><br><span class="line">      2.动态创建的子元素，也拥有注册的事件(点击)</span><br><span class="line">       var li = document.createElement(&#x27;li&#x27;);</span><br><span class="line">       li.innerHTML = &#x27;我是动态创建的&#x27;;</span><br><span class="line">       ul.appendChild(li);</span><br></pre></td></tr></table></figure>

<h3 id="contextmenu"><a href="#contextmenu" class="headerlink" title="contextmenu"></a>contextmenu</h3><p>禁止使用鼠标右键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 禁用右键菜单  contextmenu </span><br><span class="line">document.addEventListener(&#x27;contextmenu&#x27;,function(e)&#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="selectstart"><a href="#selectstart" class="headerlink" title="selectstart"></a>selectstart</h3><p>禁止选中文字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var p  = document.querySelector(&#x27;p&#x27;);</span><br><span class="line"> p.addEventListener(&#x27;selectstart&#x27;,function(e)&#123;</span><br><span class="line">     e.preventDefault()</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="常用键盘事件："><a href="#常用键盘事件：" class="headerlink" title="常用键盘事件："></a>常用键盘事件：</h3><h4 id="keydown"><a href="#keydown" class="headerlink" title="keydown"></a>keydown</h4><p>按下按键的时候触发，一直按住，会一直触发</p>
<p>识别功能键 ctrl shift 上下左右箭头等</p>
<h4 id="keypress"><a href="#keypress" class="headerlink" title="keypress"></a>keypress</h4><p>按下按键的时候触发</p>
<p>不能识别功能键 ctrl shift 等</p>
<h4 id="keyup"><a href="#keyup" class="headerlink" title="keyup"></a>keyup</h4><p>松开键盘的时候触发</p>
<h2 id="Bom"><a href="#Bom" class="headerlink" title="Bom"></a>Bom</h2><p>browser object model 游览器对象模型，把我们游览器看做一个对象，提供给我们一些方法，操作游览器的功能</p>
<h3 id="window-onload"><a href="#window-onload" class="headerlink" title="window.onload"></a>window.onload</h3><p>我们可以在这里写js </p>
<p>​       对 window -&gt; 注册监听load 事件</p>
<p>​        对 document -&gt; DOMContentLoaded</p>
<p>​       事件，当页面所有内容都加载完成之后，包括js，css图片等，执行内部回调函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  window.addEventListener(&#x27;load&#x27;,function() &#123;</span><br><span class="line">      var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">      btn.addEventListe</span><br><span class="line">info.innerHTML = &#x27;一共&#x27; + arr.length + &#x27;这张照片,这是第&#x27; + index + 1 + &#x27;张&#x27;;ner(&#x27;click&#x27;,function() &#123;</span><br><span class="line">          console.log(&#x27;ddddd&#x27;);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="window-DOMContentLoaded"><a href="#window-DOMContentLoaded" class="headerlink" title="window.DOMContentLoaded"></a>window.DOMContentLoaded</h3><p>/* 2.DOMContentLoaded:  DOM元素加载完成后，执行回调函数，此时css和img还没有加载完成 */</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#x27;DOMContentLoaded&#x27;,function() &#123;</span><br><span class="line">    var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">    btn.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">        console.log(&#x27;DOMContentLoaded&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p>调整游览器窗口大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;resize&#x27;,function() &#123;</span><br><span class="line">              /* 获取当前游览器窗口的宽度  window.innerWith */</span><br><span class="line">              // console.log(div.innerWidth);</span><br><span class="line">              if(window.innerWidth &lt; 600) &#123;</span><br><span class="line">                  div.style.display= &#x27;none&#x27;;</span><br><span class="line"></span><br><span class="line">              &#125;else&#123;</span><br><span class="line">                  div.style.display = &#x27;block&#x27;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="setTimeout-调用函数，延迟时间"><a href="#setTimeout-调用函数，延迟时间" class="headerlink" title="setTimeout(调用函数，延迟时间)"></a>setTimeout(调用函数，延迟时间)</h4><p>只执行一次，以毫秒为单位，省略的话默认为o但是最小延迟时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 第一种 */</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&#x27;dddddd&#x27;);</span><br><span class="line">    &#125;,1000);</span><br><span class="line"></span><br><span class="line">    /* 第二种写函数名的方式 */</span><br><span class="line">    function fn() &#123;</span><br><span class="line">        console.log(&#x27;dddddddddddddddddd&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(fn,5000);</span><br></pre></td></tr></table></figure>

<h4 id="清除定时器window-clearTimeout-timeoutId"><a href="#清除定时器window-clearTimeout-timeoutId" class="headerlink" title="清除定时器window.clearTimeout(timeoutId)"></a>清除定时器window.clearTimeout(timeoutId)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// window可以省略, 传入我们的定时器标记</span><br><span class="line"> var button = document.querySelector(&#x27;button&#x27;);</span><br><span class="line"> var timer1 = setTimeout(function()&#123;</span><br><span class="line">     console.log(&#x27;dddddddddddd&#x27;);</span><br><span class="line"> &#125;,5000)</span><br><span class="line"> </span><br><span class="line">     button.addEventListener(&#x27;click&#x27;,function() &#123;</span><br><span class="line">     clearInterval(timer1)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h4><p>语法:  window.setInterval(func, delay)</p>
<p>每隔一段延迟时间, 执行一次 func, 只要不清除定时器, 会一直执行.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setInterval(function()&#123;</span><br><span class="line">    console.log(&#x27;ddddddddddddddd&#x27;);</span><br><span class="line">&#125;,5000)</span><br><span class="line"></span><br><span class="line">var vd = function() &#123;</span><br><span class="line">    console.log(&#x27;lalalalala&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">回调函数的方式</span><br><span class="line">setInterval(vd,5000);</span><br></pre></td></tr></table></figure>

<h4 id="清除定时器之clearsetInterval"><a href="#清除定时器之clearsetInterval" class="headerlink" title="清除定时器之clearsetInterval"></a>清除定时器之clearsetInterval</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var timer = setInterval(function() &#123;</span><br><span class="line">                console.log(&#x27;migntain ixiix&#x27;);</span><br><span class="line">            &#125;,1000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stop.addEventListener(&#x27;click&#x27;,function()&#123;</span><br><span class="line">           clearInterval(timer)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><p>​     this指向：this在定义的时候不能确定指向，在执行的时候this才能确定</p>
<p>1.全局作用域中/普通函数调用/定时器里面，this指向 window</p>
<p>1.2 普通函数调用</p>
<p>1.3定时器里面</p>
<p>2.1方法调用中，谁调用谁用这个方法，this指向谁</p>
<p>3.0构造函数中，this指向的是构造函数的实列</p>
<h3 id="BOM游览器对象："><a href="#BOM游览器对象：" class="headerlink" title="BOM游览器对象："></a>BOM游览器对象：</h3><h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><p>代表的是整个游览器的窗口，同时window也是网页中的全局对象</p>
<h4 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h4><p>代表的当前游览器的信息，通过该对象可以来识别不同的游览器</p>
<p>navigator.userAgent</p>
<p>判断游览器的信息，是一个字符串，这个字符串中包含有用来描述游览器信息的内容</p>
<p>不同的游览器会有不同的userAgent</p>
<h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><p>代表当前游览器的地址信息，通过location可以获取地址栏信息，或者操作游览器跳转页面</p>
<p>如果直接将location属性修改为一个完整的路径，或相对路径</p>
<p>则我们页面会直接自动跳转熬该路径，并且会生成相应的历史记录</p>
<p>port</p>
<p>hostname</p>
<p>search</p>
<p>assign()</p>
<p>用来跳转到其他页面，作用和直接修改location一样</p>
<p>reload</p>
<p>用于重新加载当前页面，作用和刷新按钮一样</p>
<p>如果在方法中传递一个true，作文参数，则会强制清空缓存刷新页面</p>
<h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>代表游览器的历史记录，可以通过该对象来操作游览器的历史记录</p>
<p>​         由于隐私的原因，该对象不能获取到具体的历史记录，只能操作游览器向前和向后翻页</p>
<p>​          而且只在刚当次访问时有效</p>
<p>length属性：</p>
<p>可以获取到当次访问的链接数量</p>
<p>back()</p>
<p>可以用来回退到上一个页面</p>
<p>forward()</p>
<p>可以跳转到下一个页面，</p>
<h4 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h4><p>代表用户的屏幕的信息，通过该对象可以获取用户的显示器的相关信息</p>
<p>这些bom对象在游览器中都是作为window对象的属性保存</p>
<h3 id="js是单线程语言"><a href="#js是单线程语言" class="headerlink" title="js是单线程语言"></a>js是单线程语言</h3><p>同一时间只能做一件事（同步），所有的任务顺序都执行。</p>
<h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><h4 id="什么是线程？什么是进程？"><a href="#什么是线程？什么是进程？" class="headerlink" title="什么是线程？什么是进程？"></a>什么是线程？什么是进程？</h4><p>进程是资源分配的最小单位，线程是cpu调度的最小单位。</p>
<p>进程：一个进程就是一个正在运行的程序。（任务管理器）</p>
<p>线程：一个进程内执行着的每个任务就是一个线程。允许应用程序并发执行多个任务的一个机制。</p>
<p>一个进程可以包含多个线程</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p><strong>同步</strong>：同一时间只能做一件事情（同步），所有的任务都顺序执行，上一个任务执行完成才执行。</p>
<p>**异步:**可以同一时间执行多个任务，提高了程序的执行效率（并发执行）</p>
<p>同步任务都在主线程上执行，形成一个执行栈</p>
<h3 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h3><ol>
<li>我们先判断js任务是同步任务还是异步任务，所有的同步任务都放入主线程的执行栈中执行.</li>
<li>异步任务会提交给异步进程处理，比如click事件，setTimeout等，当满足触发条件时，异步进程会将异步任务（回调函数）放入任务队列中</li>
<li>当主线程序里的同步任务（所有的，所有的）执行完成之后，会去任务队列中查看是否有可执行的异步任务，如果有，拿到主线程中执行，执行完毕后，在去任务队列中查找，不断循环这样一个过程。</li>
</ol>
<h3 id="事件循环（event-loop）"><a href="#事件循环（event-loop）" class="headerlink" title="事件循环（event loop）"></a>事件循环（event loop）</h3><p>异步任务：又分为** 宏任务**（macTask）和 <strong>微任务</strong>(microTask) 。</p>
<h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><p>1.整个script代码块</p>
<p>2.setTimeout</p>
<p>3.setInterval</p>
<p>4.setTimediate</p>
<h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><p>\1. promise.then() /promise.catch()</p>
<p>\2. process.nextTick </p>
<p>\3. async await</p>
<p>\4. mutationObserver</p>
<p>//每执行一个宏任务，会清空(执行完成所有的)当前的微任务队列。</p>
<h3 id="offset系列属性"><a href="#offset系列属性" class="headerlink" title="offset系列属性"></a>offset系列属性</h3><p>offset偏移量 可以动态的获取我们元素的位置，大小等。</p>
<h4 id="offsetLeft"><a href="#offsetLeft" class="headerlink" title="offsetLeft"></a>offsetLeft</h4><p>获得元素距离带有根据带有定位父元素的位置, 返回值不带单位</p>
<h4 id="offsetTop"><a href="#offsetTop" class="headerlink" title="offsetTop"></a>offsetTop</h4><p>获得元素距离带有根据带有定位父元素的位置, 返回值不带单位</p>
<h4 id="offsetWidth"><a href="#offsetWidth" class="headerlink" title="offsetWidth"></a>offsetWidth</h4><p>offsetWidth 返回元素的大小, 包含border + padding + width</p>
<h4 id="offsetWidth-1"><a href="#offsetWidth-1" class="headerlink" title="offsetWidth"></a>offsetWidth</h4><p>offsetHeight返回元素的大小, 包含border + padding + width</p>
<h4 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h4><p>offsetParent 返回带有定位的父元素, 如果所有的父级都没有定位,返回body</p>
<h3 id="offsetWidth-与style获取宽高的区别"><a href="#offsetWidth-与style获取宽高的区别" class="headerlink" title="offsetWidth 与style获取宽高的区别"></a>offsetWidth 与style获取宽高的区别</h3><h4 id="style-width"><a href="#style-width" class="headerlink" title="style.width"></a>style.width</h4><ol>
<li>style.width 返回带单位的字符串 </li>
<li>style.width 只能获取行内样式中的width</li>
<li>style.width 获取到的width，不包含padding border</li>
<li>可以读写，可以获取样式，也可以设置样式值（行内的）</li>
</ol>
<h4 id="offsetWith"><a href="#offsetWith" class="headerlink" title="offsetWith"></a>offsetWith</h4><ol>
<li>offsetWidth = width + padding + border</li>
<li>offsetWidth获取的是没有单位的数值number</li>
<li>offsetWidth可以得到任意类型样式的值</li>
<li>只能是获取不能去修改</li>
</ol>
<h3 id="client系列"><a href="#client系列" class="headerlink" title="client系列"></a>client系列</h3><p>返回值是number 不带单位</p>
<h4 id="clientTop-clientLeft"><a href="#clientTop-clientLeft" class="headerlink" title="clientTop,clientLeft"></a>clientTop,clientLeft</h4><p>clientTop ,clientLeft 返回元素的border大小</p>
<h4 id="clientWidth-clientHeight"><a href="#clientWidth-clientHeight" class="headerlink" title="clientWidth ,clientHeight"></a>clientWidth ,clientHeight</h4><p>clientWidth ,clientHeight 返回元素自身的大小， 不包含 border</p>
<p>clientWidth =   width + padding</p>
<h4 id="clientWidth-和-offsetWidth-的-最大区别"><a href="#clientWidth-和-offsetWidth-的-最大区别" class="headerlink" title="clientWidth 和 offsetWidth 的 最大区别"></a>clientWidth 和 offsetWidth 的 最大区别</h4><p>clientWidth 不包含 border  offsetWidth 包含border</p>
<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>立即执行函数 :  不需要调用, 立马执行的函数（也叫自执行函数）</p>
<p> 注意：立即执行函数也可以传入参数前面第一个小括号里面写上形参，</p>
<h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>;(function(){})()</p>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>;(function(){}())</p>
<h4 id="立即执行函数的作用"><a href="#立即执行函数的作用" class="headerlink" title="立即执行函数的作用"></a>立即执行函数的作用</h4><p>创建一个独立的作用域，里面所有的变量都是局部变量</p>
<p>不会对外界的变量有影响，也就是说，不会有命名冲突的情况</p>
<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><p><strong>开发一些js插件 或者库的时候，可以用立即执行函数 包起来。</strong></p>
<h3 id="flexible"><a href="#flexible" class="headerlink" title="flexible"></a>flexible</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// 小括号包含完整的function()&#123;&#125;() 刚讲的第一种写法</span><br><span class="line">(function flexible(window, document) &#123;</span><br><span class="line">    // flexible.js 就是实时监听我们页面的大小,动态修改html根元素的字体大小</span><br><span class="line"></span><br><span class="line">     获取 html 根元素</span><br><span class="line">    var docEl = document.documentElement</span><br><span class="line">    </span><br><span class="line">    // dpr 物理像素比, 是物理像素与逻辑像素的比 (DevicePixelRatio  [ˈreɪʃioʊ])</span><br><span class="line">    // 物理像素: 设备分辨率, 硬件真实存在的像素点</span><br><span class="line">    // 逻辑像素(咱们的css像素)：document.documentElement.clientWidth</span><br><span class="line">    // 可查看 移动端html --&gt; 375 iphone6</span><br><span class="line">    var dpr = window.devicePixelRatio || 1</span><br><span class="line"></span><br><span class="line">     1. adjust body font size  设置我们 body 的字体大小</span><br><span class="line">    function setBodyFontSize() &#123;</span><br><span class="line">        // 如果页面中有body 这个元素 就设置body的字体大小</span><br><span class="line">        if (document.body) &#123;</span><br><span class="line">            document.body.style.fontSize = (12 * dpr) + &#x27;px&#x27;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果页面中没有body 这个元素，则等着 我们页面主要的DOM元素加载完毕再去设置body</span><br><span class="line">            // 的字体大小</span><br><span class="line">            document.addEventListener(&#x27;DOMContentLoaded&#x27;, setBodyFontSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setBodyFontSize();</span><br><span class="line"></span><br><span class="line">     2. set 1rem = viewWidth / 10  设置我们html元素的字体大小, 即设置rem的基本单位像素</span><br><span class="line">    // rem是相对单位，是相对html根元素。</span><br><span class="line">    // 通过它既可以做到只修改根元素就成比例地调整所有字体大小</span><br><span class="line">    function setRemUnit() &#123;</span><br><span class="line">        var rem = docEl.clientWidth / 10</span><br><span class="line">        docEl.style.fontSize = rem + &#x27;px&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setRemUnit()</span><br><span class="line"></span><br><span class="line">     3.当页面尺寸变化时, 重新设置rem</span><br><span class="line">    // reset rem unit on page resize  当我们页面尺寸大小发生变化的时候，要重新设置下rem 的大小</span><br><span class="line">    window.addEventListener(&#x27;resize&#x27;, setRemUnit)</span><br><span class="line">        // pageshow 重新加载页面触发的事件 load事件 看视频</span><br><span class="line">        // pageshow 兼容火狐  load</span><br><span class="line">    window.addEventListener(&#x27;pageshow&#x27;, function(e) &#123;</span><br><span class="line">        // e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要从新计算一下rem 的大小</span><br><span class="line">        if (e.persisted) &#123;</span><br><span class="line">            setRemUnit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">     4.兼容0.5px处理 </span><br><span class="line">    // detect 0.5px supports  有些移动端的浏览器不支持0.5像素的写法</span><br><span class="line">    if (dpr &gt;= 2) &#123;</span><br><span class="line">        // https://zhuanlan.zhihu.com/p/371898337</span><br><span class="line">        var fakeBody = document.createElement(&#x27;body&#x27;)</span><br><span class="line">        var testElement = document.createElement(&#x27;div&#x27;)</span><br><span class="line">        testElement.style.border = &#x27;.5px solid transparent&#x27;</span><br><span class="line">        fakeBody.appendChild(testElement)</span><br><span class="line">        docEl.appendChild(fakeBody)</span><br><span class="line">        if (testElement.offsetHeight === 1) &#123;</span><br><span class="line">            // 真正生效的是hairlines这个样式</span><br><span class="line">            // 无法兼容安卓设备、 iOS 8 以下设备 // 2014</span><br><span class="line">            docEl.classList.add(&#x27;hairlines&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">        docEl.removeChild(fakeBody)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(window, document))</span><br><span class="line"></span><br><span class="line">//flexible作用:  我们可以用flexible 配合rem来做页面自适应.</span><br></pre></td></tr></table></figure>

<h3 id="scroll系列"><a href="#scroll系列" class="headerlink" title="scroll系列"></a>scroll系列</h3><h4 id="scrollHeight"><a href="#scrollHeight" class="headerlink" title="scrollHeight"></a>scrollHeight</h4><p>scrollHeight返回元素内容自身的实际高度, 包含内容超出盒子未显示部分的高度并且包括padding，不包含边框</p>
<h4 id="scrollTop"><a href="#scrollTop" class="headerlink" title="scrollTop"></a>scrollTop</h4><p>scrollTop返回元素被卷去的头部   不能用来监听页面的</p>
<h3 id="window-pageYOffset"><a href="#window-pageYOffset" class="headerlink" title="window.pageYOffset"></a>window.pageYOffset</h3><p>页面被卷去的头部</p>
<h3 id="动画原理："><a href="#动画原理：" class="headerlink" title="动画原理："></a>动画原理：</h3><p>​        动画原理</p>
<p>​        1.获得盒子当前位置  offsetLeft</p>
<p>​        2.让盒子在当前位置加上1个移动距离</p>
<p>​        3.利用定时器,不断重复这个操作, 最后加上一个结束条件.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">var timer = setInterval(function()&#123;</span><br><span class="line">    div.style.left = div.offsetLeft +1 + &#x27;px&#x27;;</span><br><span class="line"></span><br><span class="line">    if(div.offsetLeft &gt;= 130)&#123;</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;,15)</span><br></pre></td></tr></table></figure>

<h3 id="简单动画的封装"><a href="#简单动画的封装" class="headerlink" title="简单动画的封装"></a>简单动画的封装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 封装一个简单的动画函数</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">var span = document.querySelector(&#x27;span&#x27;);</span><br><span class="line"> function animate(obj ,target) &#123; //target代表需要停止目标的位置</span><br><span class="line">    obj.timer = setInterval(function()&#123;   </span><br><span class="line">        if(obj.offsetLeft &gt;= target)&#123;</span><br><span class="line">            clearInterval(this.timer);</span><br><span class="line">        &#125;  </span><br><span class="line">        obj.style.left = obj.offsetLeft + 1 + &#x27;px&#x27;;          </span><br><span class="line">    &#125;,15)          </span><br><span class="line">&#125;</span><br><span class="line">animate(div,130);</span><br></pre></td></tr></table></figure>

<h3 id="缓动画原理"><a href="#缓动画原理" class="headerlink" title="缓动画原理"></a>缓动画原理</h3><p>​        缓动动画函数封装obj目标对象target目标位置</p>
<p>​        思路：</p>
<p>​        1.让盒子每次移动的距离慢慢变小， 速度就会慢慢落下来。</p>
<p>​        2.核心公式：(目标值 - 现在的位置) / 10做为每次移动的距离步长</p>
<p>​        3.停止的条件是： 让当前盒子位置等于目标位置就停止定时器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 速度 = 路程 / 时间</span><br><span class="line">// 时间: 每隔多少ms, 15ms 是一定的.</span><br><span class="line">// 步长公式 :  (目标值 - 现在的位置) / 10   作为步长</span><br><span class="line">var span = document.querySelector(&#x27;span&#x27;);</span><br><span class="line">var button = document.querySelector(&#x27;button&#x27;)</span><br><span class="line">function animate(obj, target) &#123;</span><br><span class="line">    var step = (target - obj.offsetLeft) / 10;</span><br><span class="line">    /* 应为每次点击变得速度都不一样每次点击都会调用则需要清楚以下 */</span><br><span class="line">    clearInterval(obj.timer)</span><br><span class="line">    obj.timer = setInterval(function () &#123;</span><br><span class="line">        if (obj.offsetLeft &gt; = target) &#123;</span><br><span class="line">            clearInterval(obj.timer);</span><br><span class="line">        &#125;</span><br><span class="line">        obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;;</span><br><span class="line">    &#125;, 15)</span><br><span class="line">&#125;</span><br><span class="line">button.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    animate(span, 500);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="缓动画添加回调函数"><a href="#缓动画添加回调函数" class="headerlink" title="缓动画添加回调函数"></a>缓动画添加回调函数</h3><p>​       // 给封装的函数添加回调函数callback(); </p>
<p>​        // 回调函数: 回头再调用的函数, 也就是当满足触发条件, 再调用的函数</p>
<p>​        // 函数也可以作为参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function animate(obj, target,callback) &#123;</span><br><span class="line">                clearInterval(obj.timer)</span><br><span class="line">                obj.timer = setInterval(function()&#123;</span><br><span class="line">                    var step = (target - obj.offsetLeft) / 10</span><br><span class="line">                    step = step &gt; 0 ? Math.ceil(step) : Math.floor(step)</span><br><span class="line">                    /* 当到达指定的位置 */</span><br><span class="line">                    if (obj.offsetLeft == target)&#123;</span><br><span class="line">                        /* 应为每次点击都会被调用,所以需要清楚定时器 */</span><br><span class="line">                        clearInterval(obj.timer);</span><br><span class="line">                        /* 判断这个函数是否存在如果不存在则不调用 */</span><br><span class="line">                        // 普通写法</span><br><span class="line">                        /* if(callback)&#123;</span><br><span class="line">                              callback(); </span><br><span class="line">                        &#125; */</span><br><span class="line">                        callback&amp;&amp;callback(); </span><br><span class="line">                    &#125;</span><br><span class="line">                    obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;</span><br><span class="line">                &#125;, 15)</span><br><span class="line">            &#125;</span><br><span class="line">  var fn = function()&#123;</span><br><span class="line">                span.style.backgroundColor = &#x27;orange&#x27;;</span><br><span class="line">                span.style.width = &#x27;300px&#x27;;</span><br><span class="line">                span.style.height = &#x27;300px&#x27;;</span><br><span class="line">                span.style.transform = &#x27;rotate(3600deg)&#x27;;</span><br><span class="line">                span.style.borderRadius = &#x27;50%&#x27;;</span><br><span class="line">                span.style.transition = &#x27;all 2s&#x27;;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            btn800.addEventListener(&#x27;click&#x27;,function()&#123;</span><br><span class="line">                animate(span,800,fn);</span><br><span class="line">            &#125;)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>手机端手指的触摸是触发</p>
<h4 id="touchmove"><a href="#touchmove" class="headerlink" title="touchmove"></a>touchmove</h4><p>模拟手机按住手机屏幕不放。</p>
<h4 id="touchend"><a href="#touchend" class="headerlink" title="touchend"></a>touchend</h4><p>touchend：手指在dom元素上离开时候触发。按住离开后会触发</p>
<h3 id="触摸事件对象"><a href="#触摸事件对象" class="headerlink" title="触摸事件对象"></a>触摸事件对象</h3><p> 触摸事件对象</p>
<p>​        \1. 获取元素</p>
<p>​        \2. 手指触摸DOM元素事件</p>
<p>​         事件对象：当某个事件触发的时候，和这个事件相关的系列信息集合都放在这个event事件对象里面</p>
<p>回顾：当某个事件触发的时候，和这个事件相关的系列信息集合都放在这个event对象中。</p>
<h4 id="e-touches"><a href="#e-touches" class="headerlink" title="e.touches"></a>e.touches</h4><p>所有正在触摸屏幕的所有手指的列表信息（伪数组）</p>
<h4 id="e-targetTouches"><a href="#e-targetTouches" class="headerlink" title="e.targetTouches"></a>e.targetTouches</h4><p>所有正在触摸当前dom元素的手指列表信息 也是一个伪数组</p>
<h4 id="e-targetTouches-0-pageX"><a href="#e-targetTouches-0-pageX" class="headerlink" title="e.targetTouches[0].pageX"></a>e.targetTouches[0].pageX</h4><p>可以获取手指触摸dom元素时, 手指相对于页面文档的坐标</p>
<h3 id="e-changedTouches"><a href="#e-changedTouches" class="headerlink" title="e.changedTouches"></a>e.changedTouches</h3><p>手指状态发生改变时的手指列表信息</p>
<h3 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h3><h4 id="classList-toggle"><a href="#classList-toggle" class="headerlink" title="classList.toggle();"></a>classList.toggle();</h4><p>通过ClassList.toggle为元素切换类,将它放在点击事件中若检测到没有color类就添加，若检测到有color类就删除</p>
<h4 id="classList-add"><a href="#classList-add" class="headerlink" title="classList.add()"></a>classList.add()</h4><p>通过ClassList.add()向元素添加一个或多个类名;</p>
<h4 id="classList-remove"><a href="#classList-remove" class="headerlink" title="classList.remove()"></a>classList.remove()</h4><p>通过ClassList.remove()删除元素的一个或多个类名;</p>
<h3 id="fastclick插件"><a href="#fastclick插件" class="headerlink" title="fastclick插件"></a>fastclick插件</h3><p>   // 产生300ms延迟的原因</p>
<p>​        // 由于移动端会有双击缩放的这个操作，因此浏览器在click之后要等待300ms，</p>
<p>​        // 看用户有没有下一次点击，也就是这次操作是不是双击。</p>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p> 解决方案一；</p>
<p>​        // <!-- <meta name="viewport" content="user-scalable=no" > --></p>
<p>​        // <!-- user-scalable=no ：禁止用户自由缩放，runoob --></p>
<h3 id="本地存储"><a href="#本地存储" class="headerlink" title="*****本地存储"></a>*****本地存储</h3><h4 id="sessionStorage（存储数据，字符串）"><a href="#sessionStorage（存储数据，字符串）" class="headerlink" title="sessionStorage（存储数据，字符串）"></a>sessionStorage（存储数据，字符串）</h4><p>​    sessionStorage的考点；</p>
<p>​        1.生命周期 ：是关闭当前窗口结束  (也就是关闭了窗口Tab，数据消失)</p>
<p>​        2.数据共享 : 同一个窗口(tab,页面)  下数据是可以共享的。</p>
<p>​        3.存储大小 : sessionStorage  存储大小 5m  localStrorage存储大小也是5m</p>
<p>​        4.方法</p>
<p>​           设置 : sessionStorage.setItem(key,value);</p>
<p>​           获取 : sessionStorage.getItem(key)</p>
<p>​           删除 : sessionStorage.removeItem(key);</p>
<p>​           清空 : sessionStorage.clear();</p>
<p>​        sessionStorage / localStorage : 刷新页面, 数据还是存在浏览器里面的</p>
<h4 id="localStorage（存储数据，字符串）"><a href="#localStorage（存储数据，字符串）" class="headerlink" title="localStorage（存储数据，字符串）"></a>localStorage（存储数据，字符串）</h4><p>​    localStorage的考点</p>
<p>​        1.生命周期  :  永久生效, 除非手动删除, 否则关闭浏览器也会存在</p>
<p>​        2.数据共享  :  可以多窗口(页面)共享 (同一个浏览器可以共享)</p>
<p>​        3.存储大小  : sessionStorage存储大小 5M  localStorage存储大小也是5M</p>
<p>​        4.方法</p>
<p>​           设置 : localStorage.setItem(key, value)</p>
<p>​           获取 : localStorage.getItem(key)</p>
<p>​           删除 : localStorage.removeItem(key) </p>
<p>​           清空 : localStorage.clear()</p>
<p>​        sessionStorage / localStorage : 刷新页面, 数据还是存在浏览器里面的</p>
<h3 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h3><p>  实际开发, 咱们存储的一般是对象或者数组形式(字符串)的数据 ===&gt; JSON格式的字符串</p>
<p> 注意, localStorage/ sessionStorage  存储的是字符串</p>
<h3 id="JSON的两个方法"><a href="#JSON的两个方法" class="headerlink" title="JSON的两个方法"></a>JSON的两个方法</h3><h4 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h4><p> JSON.stringify()  将对象转换成JSON格式的字符串</p>
<h4 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h4><p>JSON.parse()  将JSON格式的字符串转换为对象形式</p>
<p>   当我们想要吧，对象，或者数组， 这样复杂的数据类型存到本地里面，需要转换。</p>
<h3 id="线程和进程-1"><a href="#线程和进程-1" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>CPU一次只能运行一个任务。</p>
<p>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。</p>
<p>线程就好比车间里的工人。一个进程可以包括多个线程。</p>
<p>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</p>
<p>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</p>
<p>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81">“互斥锁”</a>（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</p>
<p>还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</p>
<p>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Semaphore_(programming)">“信号量”</a>（Semaphore），用来保证多个线程不会互相冲突。</p>
<p>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/08/js%E9%AB%98%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="石化敏的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/08/js%E9%AB%98%E7%BA%A7/" class="post-title-link" itemprop="url">js高级</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-08 16:27:44 / 修改时间：20:31:45" itemprop="dateCreated datePublished" datetime="2022-07-08T16:27:44+08:00">2022-07-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js%E9%AB%98%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">js高级</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.4k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="回顾："><a href="#回顾：" class="headerlink" title="回顾："></a>回顾：</h2><p>实例：实例对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person ()&#123;  //构造函数   类型</span><br><span class="line">   this.name = name;</span><br><span class="line">   this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">var  p = new Person() 根据类型创建的实例对象</span><br></pre></td></tr></table></figure>

<p>类型：类型对象</p>
<h3 id="★★★★undefined-与-null-的区别"><a href="#★★★★undefined-与-null-的区别" class="headerlink" title="★★★★undefined 与 null 的区别"></a>★★★★undefined 与 null 的区别</h3><p>undefined 代表了定义了为赋值。</p>
<p>null 定义并赋值了</p>
<h3 id="什么时候给变量赋值null"><a href="#什么时候给变量赋值null" class="headerlink" title="什么时候给变量赋值null"></a>什么时候给变量赋值null</h3><p>初始赋值，表明将要赋值为对象</p>
<p>结束前。让对象成为垃圾对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始赋值为null，表明将要赋值为对象。</span><br><span class="line">var b = null;</span><br><span class="line">确定对象也赋值</span><br><span class="line">b = [&#x27;&#x27;,1] 数组也是对象</span><br><span class="line">最后</span><br><span class="line">b = null 让b指向对象的垃圾对象（别垃圾回收器回收）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数据类型和变量类型"><a href="#数据类型和变量类型" class="headerlink" title="数据类型和变量类型"></a>数据类型和变量类型</h3><p>数据类型分为</p>
<p>1.基本数据类型</p>
<p>2.对象类型</p>
<p>变量类型：（变量内存值得类型）</p>
<p>1.基本类型：保存就是基本类型对的数据</p>
<p>2.引用类型：保存的就是地址值</p>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>存储在内存中代表特定信息的‘东东’,‘本质上是0101…’</p>
<p>数据的特点：可传递 ，可运算；</p>
<p>一切皆数据:</p>
<p>内存所有操作的目标：数据</p>
<p>​     算术运算：</p>
<p>​     逻辑运算：</p>
<p>​     赋值</p>
<p>​    运行函数</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1656387181496-619e80e8-dc59-47c5-8d1a-ca60cedb4eb5.png" alt="img"></p>
<p>*内存条通电以后产生的可存储数据的空间（临时的）</p>
<p>*内存产生和死亡：内存条（电路板）==》通电==》产生内存空间==》存储数据==》处理数据==》断电==》数据和空间消失</p>
<p>*一块小内存的两个数据</p>
<p>   内部存储的数据</p>
<p>​    地址值</p>
<h4 id="内存的分类"><a href="#内存的分类" class="headerlink" title="内存的分类"></a>内存的分类</h4><p>栈：全局变量，局部变量</p>
<p>堆：对象</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>可变化的量,由变量名和变量值组成</p>
<p>每个变量都对应一块小内存，边量名用来查找对应的内存，变量值就是内存中保存的数据</p>
<h3 id="内存，数据，变量三者之间的关系"><a href="#内存，数据，变量三者之间的关系" class="headerlink" title="内存，数据，变量三者之间的关系"></a>内存，数据，变量三者之间的关系</h3><p>内存用来存储数据的空间</p>
<p>变量是内存的标识</p>
<h3 id="内存和赋值的关系："><a href="#内存和赋值的关系：" class="headerlink" title="内存和赋值的关系："></a>内存和赋值的关系：</h3><p>var a = xxx;   a内存中保存的是什么？</p>
<p>xxx 是基本数据，保存的是这个数据</p>
<p>xxx是对象，保存的就是这个数据</p>
<p>xxx是一个变量，保存的xxx的内存内容（可能是基本数据类型，也可能是地址值）</p>
<p>如果数据是对象： 保存的是对象 的地址。</p>
<h3 id="关于引用变量赋值问题"><a href="#关于引用变量赋值问题" class="headerlink" title="关于引用变量赋值问题"></a>关于引用变量赋值问题</h3><p>2个引用变量的指向是同一个对象，通过一个变量修改对象内部的数据，另一个变量看到的是修改之后的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;name: &#x27;tom&#x27;&#125;</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj1.name = &#x27;jack&#x27;;</span><br><span class="line">console.log(obj2.name); //jack</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改看见这个数据另一个变量修改之后的数据</p>
<h2 id="在js调用函数时传递变量参数时，是值传递还是引用传递"><a href="#在js调用函数时传递变量参数时，是值传递还是引用传递" class="headerlink" title="在js调用函数时传递变量参数时，是值传递还是引用传递"></a>在js调用函数时传递变量参数时，是值传递还是引用传递</h2><p>理解1： 都是值（基本值\地址值）传递。</p>
<p>理解2：可能是值传递，也可能是应用传递（地址值）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var a = 3</span><br><span class="line">function(a) &#123;</span><br><span class="line">    var a = a+1</span><br><span class="line">&#125;</span><br><span class="line">f(a)</span><br><span class="line"></span><br><span class="line">a = 3</span><br><span class="line"></span><br><span class="line">传递的是一个地址值，并没有把这个对象传递过去</span><br><span class="line">function f3(obj)&#123;</span><br><span class="line">  console.log(obj.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: &#x27;tom&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f3(obj)</span><br></pre></td></tr></table></figure>

<h2 id="js引擎如何管理内存"><a href="#js引擎如何管理内存" class="headerlink" title="js引擎如何管理内存"></a>js引擎如何管理内存</h2><h3 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h3><p>*分配小内存空间，得到他的使用权限</p>
<p>*存储数据，可以反复进行操作</p>
<p>*释放小内存空间</p>
<h3 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h3><p>*局部变量：函数执行完成自动释放</p>
<p>*对象：成为垃圾对象==》 垃圾回收器回收</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>*多个数据的封装体</p>
<p>*用来保存多个各数据的容器</p>
<p>*一个对象代表现实中的一个事物</p>
<h3 id="为什么要用对象"><a href="#为什么要用对象" class="headerlink" title="为什么要用对象"></a>为什么要用对象</h3><p>统一管理多个数据</p>
<h3 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a>对象的组成</h3><p>属性：属性名（字符串）和属性值（任意）组成</p>
<p>方法：一种特别的属性（属性的值是函数）</p>
<h3 id="如何访问对象内部数据"><a href="#如何访问对象内部数据" class="headerlink" title="如何访问对象内部数据"></a>如何访问对象内部数据</h3><p>.属性名 编码简单，有时候不能用<br>[‘’] 编码麻烦，能通用</p>
<p>注意：什么条件下必须使用[‘属性名’]的方式？</p>
<ol>
<li>属性名包含特殊字符： -空格</li>
<li>变量名不确定</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p = &#123;&#125;</span><br><span class="line">给对象p.content-type = &#x27;text/json&#x27; // 不能用</span><br><span class="line">p[&#x27;content-type&#x27;] = &#x27;text/json&#x27;</span><br><span class="line"></span><br><span class="line">2.变量名不确定   用一个变量可以灵活地给值当变量变换的时候就可以去找其他值</span><br><span class="line">var propName = &#x27;myAge&#x27;;</span><br><span class="line">   var value = 18;</span><br><span class="line">  p.propName = value;</span><br><span class="line">console.log(p.propName);</span><br><span class="line">p[propName] = value;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1656939516315-c6b7123a-b0ea-44b5-a7b9-2846b9758613.png" alt="img"></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="什么是函数？"><a href="#什么是函数？" class="headerlink" title="什么是函数？"></a>什么是函数？</h3><p>实现特定功能的n条语句的封装体</p>
<p>只有函数是可以执行的，其他类型的数据不能执行</p>
<h3 id="为什么要使用函数？"><a href="#为什么要使用函数？" class="headerlink" title="为什么要使用函数？"></a>为什么要使用函数？</h3><p>实现代码的复用</p>
<p>便于阅读交流。</p>
<h3 id="如何定义函数"><a href="#如何定义函数" class="headerlink" title="如何定义函数"></a>如何定义函数</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>function dd() {}</p>
<h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><p>var res =  function (){}</p>
<h3 id="如何调用执行函数"><a href="#如何调用执行函数" class="headerlink" title="如何调用执行函数"></a>如何调用执行函数</h3><p>test();</p>
<p>obj.text(); 不能直接调用，根本没有</p>
<p>new text();  </p>
<p>text.call（）；可以让一个函数成为指定任意对象的方法进行调用</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#x27;btn&#x27;).onclick = function() &#123;</span><br><span class="line">  // dom事件回调函数</span><br><span class="line">  console.log(&#x27;ddddd&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">  // 定时器回调函数</span><br><span class="line">  console.log(&#x27;ddddd&#x27;);</span><br><span class="line">&#125;,2000)</span><br></pre></td></tr></table></figure>

<h3 id="什么是回调函数"><a href="#什么是回调函数" class="headerlink" title="什么是回调函数"></a>什么是回调函数</h3><p>1.你定义的</p>
<ol>
<li>你没有调用</li>
<li>但最终他执行了</li>
</ol>
<h3 id="常见的回调函数"><a href="#常见的回调函数" class="headerlink" title="常见的回调函数"></a>常见的回调函数</h3><p>dom事件回调函数</p>
<p>定时器回调函数</p>
<p>ajax请求回调函数</p>
<p>声明周期回调函数</p>
<h2 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h2><p>Immediately-Invoked Function Expression</p>
<p>立即执行函数</p>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>隐藏实现</p>
<p>不会污染外部命名空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;&#125;)();  匿名函数自调用</span><br><span class="line">(function()&#123;&#125;());</span><br></pre></td></tr></table></figure>

<h2 id="函数中的this"><a href="#函数中的this" class="headerlink" title="函数中的this"></a>函数中的this</h2><h3 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h3><p>所有的函数内部都有一个变量this</p>
<p>任何函数本质上都是通过某个对象来调用的，如果没有直接指定就是window</p>
<p>他的值是调用函数的当前对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person(color)&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">  this.color = color;</span><br><span class="line">  this.getColor = function () &#123; </span><br><span class="line">    console.log(this);</span><br><span class="line">    return this.color;</span><br><span class="line">   &#125;</span><br><span class="line">   this.setColor = function(color)&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    this.color = color;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person(&#x27;red&#x27;);         this = window</span><br><span class="line">var p = new Person(&#x27;yellow&#x27;);    person这个对象</span><br><span class="line">p.getColor();    p</span><br></pre></td></tr></table></figure>

<h3 id="如何确定this-的值"><a href="#如何确定this-的值" class="headerlink" title="如何确定this 的值"></a>如何确定this 的值</h3><p>test() window;</p>
<p>p.test() p</p>
<p>new test() 新创建的对象</p>
<p>p.call(obj)  obj</p>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>只能分别数值，字符串，布尔值，undefined，function</p>
<p>不能识别：null 与 object , object和array</p>
<h2 id="函数的高级"><a href="#函数的高级" class="headerlink" title="函数的高级"></a>函数的高级</h2><h3 id="函数的prototype属性"><a href="#函数的prototype属性" class="headerlink" title="函数的prototype属性"></a>函数的prototype属性</h3><p>每个函数都有一个prototype属性，他默认指向一个object空对象（即称为：原型对象）</p>
<p>原型对象中有一个属性constructor,他指向函数对象</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1657001262237-faffe7e7-e11d-40f5-ab15-8ed639a13bd8.png" alt="img"></p>
<h3 id="给原型对象添加属性（一般都是方法）"><a href="#给原型对象添加属性（一般都是方法）" class="headerlink" title="给原型对象添加属性（一般都是方法）"></a>给原型对象添加属性（一般都是方法）</h3><p>作用：函数的所有实例对象自动拥有原型中的属性（方法）</p>
<h3 id="显示原型与隐式原型"><a href="#显示原型与隐式原型" class="headerlink" title="显示原型与隐式原型"></a>显示原型与隐式原型</h3><p>1.每个函数function都有一个prototype,即显示原型（属性）</p>
<p>2.每个实例对象都有一个__proto__,可称之为隐式原型（属性）</p>
<p>3.对象的隐式原型的值为其对应构造函数的显示原型的值</p>
<p>4.内存结构</p>
<p>5.总结：</p>
<pre><code>     函数的prototype属性：在定义函数时自动添加的，默认值是一个空Object对象
</code></pre>
<p>对象的__proto__属性: 在创建对象时自动添加的，默认值为构造函数的prototype属性值</p>
<p>程序员能直接操作显示原型，但不能直接操作隐式原型（es6之前）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1657002965223-3993955f-ca8c-4f34-9cea-e2ee54052f4e.png" alt="img"></p>
<h3 id="原型链（图解）"><a href="#原型链（图解）" class="headerlink" title="原型链（图解）"></a>原型链（图解）</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1657004175959-f834cb6c-4b6f-4f13-b838-5d37bb68fd8f.png" alt="img"></p>
<h4 id="访问一个对象的属性时"><a href="#访问一个对象的属性时" class="headerlink" title="访问一个对象的属性时"></a>访问一个对象的属性时</h4><p>现在自身寻找，找到返回</p>
<p>如果没有找到，在沿着__proto__这条链向上查找，找到返回</p>
<p>如果最终没找到，则返回undefined</p>
<h3 id="构造函数-原型-实体对象的关系"><a href="#构造函数-原型-实体对象的关系" class="headerlink" title="构造函数/原型/实体对象的关系"></a>构造函数/原型/实体对象的关系</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1657006894784-d528d57f-5629-4c25-a482-cfbb37f876ae.png" alt="img"></p>
<h3 id="构造函数-原型-实体对象的关系2"><a href="#构造函数-原型-实体对象的关系2" class="headerlink" title="构造函数/原型/实体对象的关系2"></a>构造函数/原型/实体对象的关系2</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1657110362578-41810fd3-a120-4726-95f8-649af77f8cab.png" alt="img"></p>
<h3 id="实列对象的隐式原型等于构造函数的显示原型"><a href="#实列对象的隐式原型等于构造函数的显示原型" class="headerlink" title="实列对象的隐式原型等于构造函数的显示原型"></a>实列对象的隐式原型等于构造函数的显示原型</h3><p>var fn = new Fn();</p>
<p>//内部执行代码 this.<strong><strong>proto</strong></strong>      = Fn.prototype</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>函数的显示原型指向的对象默认是空Object实例对象（但Object不满足）</p>
<p>Object.prototype instanceof Object   false</p>
<p>所有函数都是Function(构造函数)的实例（包含Function）</p>
<p>Function.**proto **=== Function.ptototype  // true</p>
<p>Object的原型对象是原型链的尽头</p>
<p>Object.prototype.<strong>proto</strong> //null</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><p>prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.<strong>proto</strong> === Foo.prototype</p>
<h4 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h4><p>__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，<br>一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。</p>
<h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p>语法：var 变量名 = Function(‘参数’,’函数体’)</p>
<p>* 如果参数只有一个即是表示函数体。</p>
<p>* 如果参数多个，最后一个为函数体，前面的全是表示函数参数。</p>
<p>* 如果没有参数，即创建空函数。</p>
<p>Function中的参数全部是字符串。</p>
<p>每个 JavaScript 函数实际上都是一个 Function 对象。运行 (function(){}).constructor === Function // true 便可以得到这个结论。</p>
<p>JS的普通函数都是Function对象的实例，所以函数本身也是一个对象，就像var一样，只不过这个对象具有可调用特征而已。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">    console.log(&#x27;你好&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line"></span><br><span class="line">var f2 = new Function(&#x27;x,y&#x27;,&#x27;console.log(x,y);&#x27;)</span><br><span class="line"></span><br><span class="line">f2(1,2);</span><br></pre></td></tr></table></figure>

<p>原型继承总结：</p>
<p>1，任何函数继承自Function.prototype</p>
<p>2，任何对象最终继承自 Object.prototype</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1657019936114-589a6e7a-2c16-45e1-a2fd-488f799eb23d.png" alt="img"></p>
<h3 id="原型链属性的问题"><a href="#原型链属性的问题" class="headerlink" title="原型链属性的问题"></a>原型链属性的问题</h3><p>1.读取对象的属性值时：会自动到原型链中查找</p>
<p>2.设置对象的属性时：不会查找原型链，如果当前对象中没有此属性，直接添加次属性并设置其值。</p>
<p>3.方法一般定义在原型中，属性一般通过构造函数定义在对象本身上</p>
<h3 id="探索instanceof-是如何判断的"><a href="#探索instanceof-是如何判断的" class="headerlink" title="探索instanceof 是如何判断的"></a>探索instanceof 是如何判断的</h3><p>表达式：A instanceof B</p>
<p>如果B函数的显示原型对象在A对象的原型链上，返回true,否则返回false。</p>
<p>2.Function 是通过new自己产生的实例。</p>
<h2 id="原型面试题"><a href="#原型面试题" class="headerlink" title="原型面试题"></a>原型面试题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1657110628459-97f0b7e6-ca1b-49b1-ba9a-4fc4a0ec474b.png" alt="img"></p>
<h2 id="变量的提升与函数提升"><a href="#变量的提升与函数提升" class="headerlink" title="变量的提升与函数提升"></a>变量的提升与函数提升</h2><h3 id="变量的声明提升"><a href="#变量的声明提升" class="headerlink" title="变量的声明提升"></a>变量的声明提升</h3><p>通过var定义的（声明）的变量，在定义语句之前就可以访问到</p>
<p>值：undefined</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  var a = 2;</span><br><span class="line"> function Foo() &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">  var a = 3</span><br><span class="line"> &#125;</span><br><span class="line">Foo()</span><br></pre></td></tr></table></figure>

<h3 id="函数的声明提升"><a href="#函数的声明提升" class="headerlink" title="函数的声明提升"></a>函数的声明提升</h3><p>通过function声明的函数，在之前就可以直接调用</p>
<p>值：函数定义（对象）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Foo()</span><br><span class="line">var b = 3;</span><br><span class="line"></span><br><span class="line">function Foo() &#123;</span><br><span class="line">  console.log(&#x27;d&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><h3 id="代码分类"><a href="#代码分类" class="headerlink" title="代码分类"></a>代码分类</h3><p>全局代码</p>
<p>函数代码</p>
<h3 id="全局执行代上下文"><a href="#全局执行代上下文" class="headerlink" title="全局执行代上下文"></a>全局执行代上下文</h3><p>在执行全局代码前将window确定为全局执行上下文</p>
<p>对全局数据进行预处理</p>
<p>var 定义的全局变量==&gt;undefined，添加window属性</p>
<p>function声明的全局函数==&gt;赋值（fun），添加为window的方法</p>
<p>this=&gt;赋值（window）</p>
<p>开始执行全局代码</p>
<h3 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h3><p>在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象</p>
<p>对局部数据进行预处理</p>
<p>形参变量==&gt;赋值（实参）==&gt;添加为执行上下文的属性</p>
<p>arguments==&gt;赋值(fun),添加为执行上下文的属性</p>
<p>var定义的局部变量==&gt;undefined,添加为执行上下文的属性</p>
<p>function声明的函数==&gt;赋值（fun）,添加为执行上下文的方法</p>
<p>this==&gt;赋值（调用函数的对象）</p>
<p>开始执行函数整体代码</p>
<h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>1.在全局执行前，Js引擎就会创建一个栈来存储管理所有的执行上下文对象</p>
<ol>
<li>在全局执行上下文(window)确定后，将其添加到栈中（压栈）</li>
<li>3.在函数执行上下文创建后，将其添加到栈中（压栈）</li>
<li>在当前函数执行完成后，将栈顶的对象移除（出栈）</li>
<li>当所有的代码执行完后，栈中只剩下window</li>
</ol>
<p>window 永远是第一个执行的对象</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1657195281556-a3a1da19-5146-4801-a009-98ee7e87d274.png" alt="img"></p>
<h2 id="上下文栈的面试问题"><a href="#上下文栈的面试问题" class="headerlink" title="上下文栈的面试问题"></a>上下文栈的面试问题</h2><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>理解：就是一块底盘，一个代码段所在的区域</p>
<p>它是静态的（相对于上下文对象）,在编写代码时就确定了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/08/javaScriptEcm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="石化敏的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/08/javaScriptEcm/" class="post-title-link" itemprop="url">javaScriptEcmaScript</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-08 16:27:44 / 修改时间：20:31:29" itemprop="dateCreated datePublished" datetime="2022-07-08T16:27:44+08:00">2022-07-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaScriptEcmaScript/" itemprop="url" rel="index"><span itemprop="name">javaScriptEcmaScript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="javaScript组查成部分"><a href="#javaScript组查成部分" class="headerlink" title="javaScript组查成部分"></a>javaScript组查成部分</h2><p>ECMAScript    Dom(获取整个游览器)   Bom(控制台里面console)</p>
<h2 id="js三种样式写法"><a href="#js三种样式写法" class="headerlink" title="js三种样式写法"></a>js三种样式写法</h2><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><!-- 1. 行内式的js 直接写到元素的内部 --><inputtype="button"value="唐伯虎"onclick="alert('秋香姐')"/>

<h3 id="内嵌式"><a href="#内嵌式" class="headerlink" title="内嵌式"></a>内嵌式</h3><!-- 2.内嵌式的js --><script>// alert('沙漠骆驼');</script>

<h3 id="外链式"><a href="#外链式" class="headerlink" title="外链式"></a>外链式</h3><!-- 3. 外链式js script 双标签 --><scriptsrc="my.js"></script>

<h2 id="输入和输出语句"><a href="#输入和输出语句" class="headerlink" title="输入和输出语句"></a>输入和输出语句</h2><p>prompt(‘请输入您的年龄’);</p>
<p>​      alert(‘计算的结果是’);</p>
<p>​      // console 控制台输出 给程序员测试用的  </p>
<p>​        console.log(‘我是程序员能看到的’);</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>白话：变量就是一个装东西的盒子。</p>
<p>通俗：<strong>变量是用于存放数据的容器</strong>。 我们通过 变量名 获取数据，甚至修改数据。</p>
<h2 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h2><p>- 由字母、数字、下划线_、$符号组成，</p>
<p>-严格区分大小写</p>
<p>-不能以数字以及其他符号（不包括_和$）开头</p>
<p>- 不能是保留关键字，例如：for、while。</p>
<h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><p>var age;</p>
<h3 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h3><p>age=10;</p>
<h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>我们把变量的赋值和声明称之为变量的初始化</p>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>在源码中一个固定的值得表示法</p>
<p>字面量是我们在程序中，直接写出来的值，字面上的意思。</p>
<p>var a = 100;右边我们写的固定的值这些都是字面量</p>
<p>在javascript 中直接写出来的值（value），而不是变量字面上得到意思</p>
<h3 id="函数字面量"><a href="#函数字面量" class="headerlink" title="函数字面量"></a>函数字面量</h3><p>var fn = function(){</p>
<p>​    alert(‘你好’);</p>
<p>}</p>
<p> function(){</p>
<p>​    alert(‘你好’);</p>
<p>}</p>
<p>就是函数字面量</p>
<h2 id="变量提升：就是带var-的提前-在js引擎中先执行"><a href="#变量提升：就是带var-的提前-在js引擎中先执行" class="headerlink" title="变量提升：就是带var 的提前 在js引擎中先执行"></a>变量提升：就是带var 的提前 在js引擎中先执行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(num);</span><br><span class="line">var num = 10;</span><br><span class="line">提升后js中执行的顺序</span><br><span class="line"></span><br><span class="line">//先声明 num 这一步称为 变量提升</span><br><span class="line">  var num ;</span><br><span class="line"></span><br><span class="line">console.log(num);//undefine</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>​    Number   String   null   Boolean  BigInt     Symbol     undefined</p>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>object</p>
<h2 id="变量交换"><a href="#变量交换" class="headerlink" title="变量交换"></a>变量交换</h2><p>var temp;</p>
<p>var a=1</p>
<p>var b = 2</p>
<p>temp = a</p>
<p>a = b</p>
<p>b =temp</p>
<h2 id="js注释"><a href="#js注释" class="headerlink" title="js注释"></a>js注释</h2><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>/*  */     默认快捷键 alt shift  a</p>
<p>单行注释 //   </p>
<h2 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h2><p>包括整形和浮点型</p>
<h3 id="数字型的最大值"><a href="#数字型的最大值" class="headerlink" title="数字型的最大值"></a>数字型的最大值</h3><p>Number.MAX_VALUE</p>
<h3 id="数字型的最小值"><a href="#数字型的最小值" class="headerlink" title="数字型的最小值"></a>数字型的最小值</h3><p>Number.MIN_VALUE</p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>浮点型数值的最高精度是17位小数。</p>
<h4 id="浮点型的精度问题"><a href="#浮点型的精度问题" class="headerlink" title="浮点型的精度问题"></a>浮点型的精度问题</h4><p>var result= 0.1 + 0.2 结果不是0.3 儿是0.30000000000000004  比较特殊 并不是所有的浮点都会出现</p>
<p>不要判断两个浮点书数是否相等</p>
<p>toFixed()    保留几位小数</p>
<p>var res2 = (0.1 + 0.2).toFix(1)   //保留以为小数</p>
<h3 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h3><p>超出数字的最大值和最小值就会变成Infinity和-Infinity</p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>not a number 与任何一个数字的值 都不相等包括他本身</p>
<h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p>Boolean()</p>
<p>‘’(空字符串) null undefined NaN 0 会转换成false 其它都会转换成true</p>
<h2 id="Undefined-和NULL"><a href="#Undefined-和NULL" class="headerlink" title="Undefined 和NULL"></a>Undefined 和NULL</h2><p>undefined</p>
<p>表示一个声明了没有赋值的变量，变量只声明的时候值默认是undefined</p>
<p>undefined 和数值相加是NaN</p>
<p>null </p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>模板字符串`` 反引号</p>
<p>​         var msg =<code>pink老师ggg</code>;</p>
<p>​         console.log(msg)</p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>字符串拼接使用 + </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(11 + 11);</span><br><span class="line">console.log(&#x27;hello&#x27; + &#x27; world&#x27;);</span><br><span class="line">console.log(&#x27;100&#x27; + &#x27;100&#x27;);</span><br><span class="line">console.log(&#x27;11&#x27; + 32);</span><br><span class="line">console.log(&#x27;male:&#x27; + true);</span><br></pre></td></tr></table></figure>

<p>两边只要有一个是+ 就会使用 + 连接起来</p>
<p>不管任意类型只要在字符串中含有+ 都会转变成 String</p>
<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>将一种类型转换成另一种类型：</p>
<h3 id="转换成字符型"><a href="#转换成字符型" class="headerlink" title="转换成字符型"></a>转换成字符型</h3><p>var num = 10；          console.log(num.toString())         console.log(String(num))</p>
<p>还可以使用 + </p>
<h3 id="转换成数字型"><a href="#转换成数字型" class="headerlink" title="转换成数字型"></a>转换成数字型</h3><h4 id="parsentInt"><a href="#parsentInt" class="headerlink" title="parsentInt"></a>parsentInt</h4><p>parseInt(变量),可以吧字符串类型转换为数字整型</p>
<p>会把字符第一个是数字的转换成数字直到没有数字。</p>
<p>如果字符串的第一个就是字母就不能转换就会是nan</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(parseInt(&#x27;12x&#x27;))    12</span><br><span class="line">console.log(parseInt(&#x27;12.3&#x27;))    12</span><br><span class="line">console.log(parseInt(&#x27;x12&#x27;))    NaN</span><br><span class="line">console.log(parsentInt(&#x27;33*&#x27;)) 33</span><br></pre></td></tr></table></figure>

<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>Number(变量)</p>
<h4 id="parsentFloat"><a href="#parsentFloat" class="headerlink" title="parsentFloat"></a>parsentFloat</h4><p>把字符串类型的浮点数转换成为数字型</p>
<p>console.log(parsentFloat(‘12.4’))    12.4</p>
<p>console.log(parsentFloat(‘x12’))    NaN</p>
<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>各基本类型的判断typeof 123 // “number”typeof ‘123’ // “string”typeof false //  “boolean”typeof undefined // “undefined”typeof null //  “object”typeof NaN  // Number</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p>
<h3 id="Object-prototyoe-toString-call（）"><a href="#Object-prototyoe-toString-call（）" class="headerlink" title="Object.prototyoe.toString.call（）"></a>Object.prototyoe.toString.call（）</h3><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>  //加减乘除取余</p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p> //  是由数字、运算符、变量等组成的式子 我们成为表达式   （1 + 1 ）</p>
<p>// 在我们程序里面  2 = 1 + 1   把我们的右边表达式计算完毕把返回值给左边</p>
<h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><p>只有一个操作符的运算符</p>
<h3 id="-1"><a href="#-1" class="headerlink" title="++"></a>++</h3><h4 id="前置-：先运算后返回"><a href="#前置-：先运算后返回" class="headerlink" title="前置++：先运算后返回"></a>前置++：先运算后返回</h4><h4 id="后置-：先返回，后加1"><a href="#后置-：先返回，后加1" class="headerlink" title="后置++：先返回，后加1"></a>后置++：先返回，后加1</h4><h3 id="–同理"><a href="#–同理" class="headerlink" title="–同理"></a>–同理</h3><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><p>在单独使用的时候都是一样的值</p>
<p>varage = 10;</p>
<p>​        age++; 11</p>
<p>​       ++age;  11</p>
<p>​          console.log(age)  </p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>&amp;&amp; 与 两个操作数同时为true，结果为true，否则都是false</p>
<p>|| 或 两个操作数有一个为true，结果为true，否则为false</p>
<p>!  非  取反</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>+=  -=  !=</p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>&lt;  &gt;  &gt;=  &lt;= == != === !==</p>
<p>==与===的区别：==只进行值得比较，===类型和值同时相等，则相等</p>
<p>var result = ‘55’ == 55;      // true</p>
<p>var result = ‘55’ === 55;     // false 值相等，类型不相等</p>
<p>var result = 55 === 55;     // true</p>
<h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><p>优先级从高到底</p>
<p>​    1. ()  优先级最高</p>
<p>​    2. 一元运算符  ++   –   !</p>
<p>​    3. 算数运算符  先*  /  %   后 +   -</p>
<p>​    4. 关系运算符  &gt;   &gt;=   &lt;   &lt;=</p>
<p>​    5. 相等运算符   ==   !=    ===    !==</p>
<p>​    6. 逻辑运算符 先&amp;&amp;   后||</p>
<p>​    7. 赋值运算符  =</p>
<p>​    8. 默认从左至右 除了 赋值运算 = 三目运算 ?: 指数运算 </p>
<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><h3 id="递增递减运算符-前置、后置-–"><a href="#递增递减运算符-前置、后置-–" class="headerlink" title="递增递减运算符(前置、后置)++–"></a>递增递减运算符(前置、后置)++–</h3><p>var x = ‘4’;</p>
<p>console.log(++x);</p>
<ol>
<li>如果包含的是有效数字字符串或者是有效浮点数字符串，则会将字符串转换(Number())为数值，再进行加减操作，返回值的类型是：number类型。</li>
<li>如果不包含有效数字字符串，则会将字符串的值转换为NaN,返回值的类型是：number类型。</li>
<li>如果是boolean类型，则先会把true或者false转换为1或者0，再进行加减操作，返回值的类型是：number类型。</li>
<li>如果是null类型，则先会把null转换为0，在进行加减操作，返回值的类型是：number类型。</li>
<li>如果是undefined，则先会把undefined转换为NaN，再进行加减操作，返回值的类型是：number类型。</li>
<li>如果是对象，则先会通过对象的valueOf()方法，进行转换，如果返回的是NaN，调用toString()方法，在进行前面的操作，返回值的类型是：number类型。（注：空数组[]会返回0，在进行加减操作，空对象则会返回NaN）。</li>
</ol>
<h2 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;  ||  !"></a>&amp;&amp;  ||  !</h2><p>‘’(空字符串)null undefined NaN 0 会转换成false  其他都会转换成true</p>
<h4 id="amp-amp-1"><a href="#amp-amp-1" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h4><p>如果左边为真 返回右边    </p>
<p>如果左边为假 返回左边本身</p>
<p>var x = undefined             console.log(x &amp;&amp; 2)  //值为 undefined</p>
<h4 id="-2"><a href="#-2" class="headerlink" title="||"></a>||</h4><p>​    如果左边为假 返回右边</p>
<p>​    如果左边为真 返回左边本身</p>
<h3 id="等值之间的隐式转换"><a href="#等值之间的隐式转换" class="headerlink" title="等值之间的隐式转换"></a>等值之间的隐式转换</h3><p>如果一个操作值是数值，则另一个值转换为数值进行比较</p>
<p>console.log(null == 0)  false</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>编程的三种基本结构：顺序结构，分支结构 循环结构</p>
<h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>从上到下执行的代码就是顺序结构</p>
<h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (/* 条件表达式 */) &#123;</span><br><span class="line">  // 执行语句</span><br><span class="line">&#125;else() &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="else-if"><a href="#else-if" class="headerlink" title="else if"></a>else if</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (/* 条件1 */)&#123;</span><br><span class="line">  &#125; else if (/* 条件2 */)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>想当于ifelse</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表达式1 ? 表达式2 : 表达式3</span><br><span class="line">是对if……else语句的一种简化写法</span><br></pre></td></tr></table></figure>

<ul>
<li>如果条件表达式为true，则返回表达式1的值</li>
<li>如果条件表达式为false, 则返回表达式2的值</li>
<li>简单理解:就类似于ifelse (双分支) 的简写</li>
</ul>
<h4 id="案列：数字补o-‘0-‘"><a href="#案列：数字补o-‘0-‘" class="headerlink" title="案列：数字补o  ‘0 ‘ +"></a>案列：数字补o  ‘0 ‘ +</h4><p>用于倒计时 和 时钟</p>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>可以是任意数据类型</p>
<p>如果是数字就需要转换类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch (expression) &#123;</span><br><span class="line">  case 常量1:</span><br><span class="line">    语句;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    console;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (初始化变量; 条件表达式; 操作表达式) &#123;</span><br><span class="line">       阔号里面的东西就是循环体</span><br><span class="line">&#125;</span><br><span class="line">操作表达式也叫末尾循环体, 每次循环最后执行的代码, 用于我们计数变量的更新（递增或者递减）</span><br></pre></td></tr></table></figure>

<p>案列倒三角</p>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>在条件表达式为真的时候结果为true 则执行循环体 否则 退出循环</p>
<p>执行思路  当条件表达式结果为true 则执行循环体 否则 退出循环</p>
<h4 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h4><p>再判断条件 如果条件表达式结果为真，则继续执行循环体，否则退出循环</p>
<p>for 循环和while 的区别</p>
<p>for是已经知道了次数。</p>
<p>while 可以一直循环，循环次数为知，复杂条件的判断</p>
<h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>直接退出整个循环，跳到for循环下面语句执行</p>
<h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>用于跳出本次循环</p>
<h2 id="如何debug"><a href="#如何debug" class="headerlink" title="如何debug"></a>如何debug</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1654912312738-085c0cfd-2812-4d76-b592-6eeb22cfbf19.png" alt="img"></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数就是封装了一段可以被重复调用的代码块。</p>
<p>函数就是方法，可以理解为一个工具。</p>
<h3 id="两种声明函数"><a href="#两种声明函数" class="headerlink" title="两种声明函数"></a>两种声明函数</h3><p>函数的声明提前</p>
<p>  使用函数声明形式创建的函数  function 函数() {}</p>
<p>  他会在所有的代码执行之前就被创建，所以我们可以在函数声明前调用</p>
<p>  使用函数表达式创建的函数,不会被申明提前，所以不能在声明前调用 </p>
<p>函数不调用，函数内部就不会执行。</p>
<p>​        // 函数: 封装了一段可被重复执行调用的代码块</p>
<p>​        // 调用函数的时候一定要加()!</p>
<p>​        // 声明函数时,并不会执行代码, 只有调用时, 才会执行函数内部的代码!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function  函数名（） &#123;</span><br><span class="line"> 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fun = function (x) &#123;&#125; </span><br><span class="line">fun(2)</span><br><span class="line">1.fun是变量名，他不是函数，用表达式声明的函数时匿名函数。</span><br><span class="line">但是我们调用的时候，可以用 =&gt; 变量名（） 调用</span><br><span class="line">2.表示式声明的函数也可以传参数</span><br></pre></td></tr></table></figure>

<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>函数的参数分为 <strong>形参</strong>(parameter) 和 <strong>实参</strong>(argument) , 当函数需求根据不同的值做出不同反馈时, 就需要通过使用参数。 <strong>形参</strong>为声明函数时预设的形势参数，我们可以自定义命名。 <strong>实参</strong>为调用函数时对应 <strong>形参</strong>所传递的实际参数，为所需要的原始值。</p>
<h4 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h4><ol>
<li>形式参数：在声明一个函数的时候，为了函数的功能更加灵活，有些值是固定不了的，对于这些固定不了的值。我们可以给函数设置参数。这个参数没有具体的值，仅仅起到一个占位置的作用，我们通常称之为形式参数，也叫形参。</li>
<li>实际参数：如果函数在声明时，设置了形参，那么在函数调用的时候就需要传入对应的参数，我们把传入的参数叫做实际参数，也叫实参。</li>
<li>如果函数调用时 没有传入实参 对应形参默认值为 undefined</li>
</ol>
<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>当 JavaScript 到达 return 语句，函数将停止执行。</p>
<p>如果函数被某条语句调用，JavaScript 将在调用语句之后“返回”执行代码。</p>
<h3 id="返回值详解"><a href="#返回值详解" class="headerlink" title="返回值详解"></a>返回值详解</h3><p>如果函数没有显示的使用 return语句 ，那么函数有默认的返回值：undefined</p>
<p> function demo() {</p>
<p>​            console.log(123);</p>
<p>​        }</p>
<p>​        varres2 = demo()</p>
<p>​        console.log(res2)</p>
<p>如果函数使用 return语句，那么跟再return后面的值，就成了函数的返回值</p>
<p>如果函数使用 return语句，但是return后面没有任何值，那么函数的返回值也是：undefined</p>
<p>函数使用return语句后，这个函数会在执行完 return 语句之后停止并立即退出，也就是说return后面的所有其他代码都不会再执行。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域：变量可以起作用的范围</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>​    直接编写在script标签中的js代码中，都在全局作用域中</p>
<p>​    全局作用域在页面打开创建，在页面关闭是销毁</p>
<p>​    创建的变量都会作为window对象的属性保存</p>
<p>​    创建的所有的函数都会作为window对象的方法保存</p>
<p>  补充：全局作用域中的变量都是全局变量</p>
<p>​             在页面的任意部分都会被创建到</p>
<h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p>   调用函数时创建函数作用域，函数执行（调用玩）完毕以后，函数作用域销毁</p>
<p>   每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的</p>
<p>   在函数作用域中可以访问到全局作用域中变量</p>
<p>​       在全局作用域中无法访问到函数作用域的变量</p>
<p>   当在函数作用域操作一个变量是，他会先在自身作用域中寻找如果没有就会直接使用</p>
<p>​       如果没有则向上一级作用域中寻找，直到找到全局作用域</p>
<p>​       如果全局作用域中依然没有找到则会报错。</p>
<p>   在函数中要访问全局变量可以使用window对象。</p>
<p>es6之前</p>
<ul>
<li>全局变量</li>
</ul>
<p>​         在任何地方都可以访问到的变量就是全局变量，对应全局作用域</p>
<ul>
<li>局部变量</li>
</ul>
<p>​         只在固定的代码片段内可访问到的变量，最常见的例如函数内部。对应局部作用域(函数作用域)</p>
<p>全局作用域下的变量都挂载在window对象下，window是窗口的意思，他是游览器的顶级对象。</p>
<p>函数作用域  在函数内部就是局部作用域 这个代码的名字只在函数内部其效果和作用。</p>
<p>函数的全局变量不可以访问函数内部的变量。</p>
<h3 id="从执行效率来看全局变量和局部变量"><a href="#从执行效率来看全局变量和局部变量" class="headerlink" title="从执行效率来看全局变量和局部变量"></a>从执行效率来看全局变量和局部变量</h3><p>1.全局变量中只有游览器关闭的时候才会销毁，比较占内存资源</p>
<p>2.局部变量 当我们程序执行完毕就会销毁，比较节约内存资源</p>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>ES6新增的块级作用域 {}    是一个语句，不是函数</p>
<p>使用了let ，const声明的变量，应为存在块级作用域的关系，我们不能在外部访问</p>
<p>for(){</p>
<p>let  num1;</p>
<p>}</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链  ： </p>
<p>内部函数访问外部函数的变量，</p>
<p>采取的是链式查找的方式来决定取那个值 这种结构我们称为作用域链   就近原则</p>
<p>只要是代码，就至少有一个作用域</p>
<p>如果在函数内部含有函数，那么这个作用域中又诞生一个作用域</p>
<p>当前作用域找不到这个变量，就去上层作用域域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> var num= 10</span><br><span class="line"> function fn() &#123;</span><br><span class="line">    function foo() &#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">     &#125;</span><br><span class="line">     foo()</span><br><span class="line">&#125;</span><br><span class="line">     fn();</span><br></pre></td></tr></table></figure>

<h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p>声明提升（预解析）</p>
<p>在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义</p>
<p><strong>其实相当于提前读一遍代码，找<strong><strong>var，function</strong></strong>，将变量和函数声明进行提升</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log()</span><br><span class="line">var num =10;</span><br><span class="line">相当于 </span><br><span class="line">var num；</span><br><span class="line">console.log(num)</span><br><span class="line">num = 10</span><br></pre></td></tr></table></figure>

<p>变量声明的提升是提升到当前作用域的最顶层</p>
<h3 id="函数声明的提升"><a href="#函数声明的提升" class="headerlink" title="函数声明的提升"></a>函数声明的提升</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn();</span><br><span class="line">function fn()&#123;&#125;</span><br><span class="line">提升之后</span><br><span class="line"> function fn()&#123;&#125;</span><br><span class="line">fn();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn()</span><br><span class="line">var fun = function fn() &#123;&#125;</span><br><span class="line">//提升之后</span><br><span class="line">var fun;</span><br><span class="line">fun ()</span><br><span class="line">var fun = function fn() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的定义："><a href="#数组的定义：" class="headerlink" title="数组的定义："></a>数组的定义：</h3><p>数组是一个有序的列表，可以在数组中存放任意的数据</p>
<p>并且数组的长度可以动态的调整。</p>
<p> num[num.length] = arr[i];  随着右边的赋值，数组的长度就自增</p>
<p>数组也是一个对象</p>
<p>他和我们普通对象功能相似，也是用来存储一些值的</p>
<p>不同的是普通的对象时使用字符串作为属性名的，</p>
<p>而数组时使用数字来作为索引操作元素的</p>
<p>索引：</p>
<p>   是从0开始的整数就是索引。</p>
<p>数组的存储性能比普通对象要好，在开发中我们经常使用数组来储存一些数据</p>
<h3 id="创建数组对象"><a href="#创建数组对象" class="headerlink" title="创建数组对象"></a>创建数组对象</h3><h4 id="通过实列来创建"><a href="#通过实列来创建" class="headerlink" title="通过实列来创建"></a>通过实列来创建</h4><p>var arr = new Array();</p>
<p>console.log(typeof arr)  返回 object</p>
<h4 id="通过字面量来创建"><a href="#通过字面量来创建" class="headerlink" title="通过字面量来创建"></a>通过字面量来创建</h4><p>var arr = [4,5,6,’ggg’]</p>
<p>向数组中添加元素</p>
<p>  语法：数组【索引】 = 值</p>
<p>arr[0] = 10;</p>
<p>读取数组中的元素 </p>
<p>如果读取不存在的索引，他不会报错而是返回undefined</p>
<p>获取数组的长度</p>
<p> 可以使用length属性来获取数组的长度（元素的个数）</p>
<p> 队于非连续的数组，使用length可以获取到数组的最大的索引加1</p>
<p>​    尽量不要创建非连续的数组</p>
<p>修改length</p>
<p>  如果修改的length大于原来的长度，则多出来的部分会空出来</p>
<p>  反之则多出的则会被删除。</p>
<p>向数组中的最后一个位置天添加元素</p>
<p>语法：数组【数组.lenght】</p>
<p>arr[arr.length] = 70;</p>
<p>使用字面量来创建数组</p>
<p>var arr= 【】；</p>
<p>使用构造函数创建数组时，也可以同时添加元素，将要添加的元素作为构造函数的参数传递</p>
<p> var arr= Array(10,2,0,30)</p>
<p>数组中的类型可以是任意的数据类型；</p>
<p>arr = 【’hello’ , 1,true, null , undefined】</p>
<p>同样也可以是一个对象</p>
<p>同样也可以存一个函数</p>
<p>同样也可以放一个数组</p>
<p>【【】】</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><p>向数组的末尾添加一个或多个元素，并返回数组新的长度</p>
<p>可以将要添加的元素作为方法的参数传递</p>
<p> 这样这些元素将会自动添加到数组的末尾</p>
<p>​    该方法会将数组新的长度作为返回值返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;孙悟空&quot;,&quot;唐曾&quot;];</span><br><span class="line">    arr.push(&quot;沙和尚&quot;);</span><br><span class="line">    console.log(arr);</span><br></pre></td></tr></table></figure>

<h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><p>该方法可以删除数组的最后一个元素,并将删除后的元素作为返回值返回  会影响原来数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;孙悟空&quot;,&quot;唐曾&quot;];</span><br><span class="line">arr.pop();</span><br><span class="line">console.log(arr);  //[&#x27;孙悟空&#x27;]</span><br></pre></td></tr></table></figure>

<p>arr.pop();</p>
<p>​     var arr = [“孙悟空”,”唐曾”];</p>
<p>​     arr.pop();</p>
<p>​     console.log(arr);   //[‘孙悟空’]</p>
<h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><p>向数组的开头添加一个或多个元素，并返回新的数组长度</p>
<h3 id="向前边插入元素以后，其他的元素索引会依次调整。"><a href="#向前边插入元素以后，其他的元素索引会依次调整。" class="headerlink" title="向前边插入元素以后，其他的元素索引会依次调整。"></a>向前边插入元素以后，其他的元素索引会依次调整。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;孙悟空&quot;,&quot;唐曾&quot;];</span><br><span class="line"> arr.unshift(&quot;沙和尚&quot;);</span><br><span class="line"> console.log(arr);</span><br></pre></td></tr></table></figure>

<h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><p>可以将删除的数组的第一个元素，并将删除的元素作为返回值返回。</p>
<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><p>作用是返回该数组元素的索引号 从前面开始查找</p>
<p>他只返回找到的第一个元素的索引号</p>
<p>如果这个元素在数组中不存在，没找到，返回-1</p>
<h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h3><p>es6新特性</p>
<p>arr.includes() //判断一个数组是否有某个元素，如果有返回true 否则返回false</p>
<h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p>es6新方法用來检查数组中是否含有元素有就返回true没有则返回false</p>
<h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>所谓的遍历数组，就是将数组中所有的元素都取出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;孙悟空&quot;,&quot;唐曾&quot;];</span><br><span class="line">  arr.unshift(&quot;沙和尚&quot;);</span><br><span class="line">  console.log(arr);</span><br><span class="line">  for(var i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>这个方法只支持ie8以上的游览器</p>
<p>for each方法需要一个函数作为参数</p>
<p>​    像这种函数，由我们创建但是不由我们调用，我们称为回调函数</p>
<p>   数组中有几个元素函数就会执行几次，每次执行时，游览器都会将遍历到的元素以实参的形式传递进来，我们可以来定义形参，来读取这些内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(function (value,index,obj) &#123;</span><br><span class="line">     console.log(&#x27;hello&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">第一个参数a就是当前正在遍历的元素 value</span><br><span class="line">第二个参数b就是当前正在遍历的元素的索引  index</span><br><span class="line">第三个参数就是我们正在遍历的数组  obj</span><br><span class="line">ie8不支持</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="for-of"><a href="#for-of" class="headerlink" title="for   of"></a>for   of</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3]</span><br><span class="line">for(key of arr) &#123;</span><br><span class="line">  consnole.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h2><p>slice()可以用来从数组中提取指定元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,3,&#x27;sd&#x27;];</span><br><span class="line">    console.log(arr.slice(0,1));  //值为2</span><br></pre></td></tr></table></figure>

<p>该方法不会改变原来的素组，只是将截取的元素封装到一个新数组中返回</p>
<p>slice(sart,end)</p>
<p> 1.截取开始位置的索引</p>
<p>2.截取结束的位置的索引。（结束的位置不包含）。可选</p>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p>可以用于删除数组中的指定元素</p>
<p>使用splice 会影响到原数组，会将指定元素从原数组中删除</p>
<p> 并将被删除的元素作为返回值返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,3,&#x27;sd&#x27;];</span><br><span class="line">console.log(arr.splice(1,1));</span><br><span class="line">console.log(arr); //[2,&#x27;sd&#x27;]</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<p>  第一个参数 ，表示开始位置的索引</p>
<p>  第二个参数，表示删除的数量。</p>
<p>  第三参数，可以传递一些新的元素，这些元素将会自动插入到开始位置索引</p>
<h2 id="contact"><a href="#contact" class="headerlink" title="contact()"></a>contact()</h2><p>可以连接两个或多个数组，并将新的数组返回。</p>
<p>   该方法不会对原数组产生影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&#x27;ddd&#x27;,&#x27;sd&#x27;];</span><br><span class="line">var arr2 = [&#x27;dds&#x27;, &#x27;sdd&#x27;]</span><br><span class="line">var arr3 = arr1.concat(arr2);</span><br><span class="line">console.log(arr3);    [&#x27;ddd&#x27;,&#x27;sd&#x27;,&#x27;dds&#x27;,&#x27;sdd&#x27;]</span><br><span class="line">还可以在末尾添加元素</span><br><span class="line">var arr3 = arr1.concat(arr2,&#x27;ddd&#x27;);</span><br><span class="line">console.log(arr3)     [&#x27;ddd&#x27;,&#x27;sd&#x27;,&#x27;dds&#x27;,&#x27;sdd&#x27;,&#x27;ddd&#x27;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>改方法可以将数组转换为一个字符串使用逗号隔开</p>
<p>​    该方法不会对原数组产生影响，而是将数组转换后的字符串作为结果返回。</p>
<p>在join（）中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符</p>
<p>​     如果不指定连接符，则默认使用逗号作为连接符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">默认不填就是逗号</span><br><span class="line">var arr = [2,3,&#x27;sd&#x27;];</span><br><span class="line">var result = arr.join(&#x27;@-@&#x27;); </span><br><span class="line">console.log(result)   2@-@3@-@ ....</span><br><span class="line">如果填空格就输入 &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>将数组改变为字符串。不会影响到原数组。</p>
<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h2><p> 该方法用来反转数组（前边的去后边，后边的去前边）</p>
<p> 该方法会直接修改原数组。</p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><p> 可以用来对数组中的元素进行排序</p>
<p>也会影响原始的数组，默认会对unicode 的编码进行排序。</p>
<p>即使对于纯数字的数组，使用sort()排序时，也会按照Unicode编码来排序，</p>
<p>所以对数字进排序时，可能会得到错误的结果。</p>
<p>我们可以自己来指定排序的规则</p>
<p>  我们可以在sort（）添加一个回调函数，来指定排序规则，</p>
<p>  回调函数中需要定义两个形参，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(function(a,b)&#123;</span><br><span class="line">      return a-b;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<p>  游览器将会分别使用数组中的元素作为实参去调用回调函数</p>
<p>  使用那个元素调用不确定，但是肯定的是在数组中a一定在b前边</p>
<p> 游览器会根据回调函数的返回值来决定元素的顺序， </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">每个游览器顺序不一样（谷歌版本） return -1交换位置  return 1不交换</span><br><span class="line">    arr.sort(function(a,b)&#123;</span><br><span class="line">          console.log(a);</span><br><span class="line">          if(a &lt; b)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">          &#125;else if(a&gt;b) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>简化版本想要升序的话就返回a-b;  想要降序就 b-a</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(function(a,b)&#123;</span><br><span class="line">      return a -b;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="call-和apply"><a href="#call-和apply" class="headerlink" title="call()和apply()"></a>call()和apply()</h2><p>call( )和apply()</p>
<p>一这两个方法都是函数对象的方法， 需要通过函数对象来调用</p>
<p>当对函数调用call( )和app1y( )都会调用函数执行</p>
<p>-在调用call( )和apply()可以将一一个对象指定为第一 个参数</p>
<p>   此时这个对象将会成为函数执行时的this</p>
<p>两个区别</p>
<p>call( )方法可以将实参在对象之后依次传递   fun.call(obj,2,3);</p>
<p>apply( )方法需要将实参封装到- -个数组中统- -传递   fun.apply[2,3]</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>第一个循环是控制我们需要循环的次数。  arr.length-1 </p>
<p>内层循环就是我们需要交换的次数           arr.length - i -1;   应为外层每循环一次就需要我们固定一个位置</p>
<p>在通过大的数来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var temp = 0;</span><br><span class="line">    var arr = [1,5,8,6,10,12,13,51,42,85];</span><br><span class="line">    //每次都遍历一次</span><br><span class="line">    for (var i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">      for(var j = arr.length-1; j &gt;= i; j--)</span><br><span class="line">          if(arr[j] &gt; arr[j+1]) &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+1];    </span><br><span class="line">            arr[j+1] = temp;</span><br><span class="line">          &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    console.log(arr);</span><br></pre></td></tr></table></figure>

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>根据不同的对象可以访问不同的值</p>
<p>以函数的形式调用this永远都是window</p>
<p>以方法的形式调用时，this就是调用方法的那个对象。</p>
<p>使用call和apply调用时，this是指定的那个对象。</p>
<p>解析器在调用函数每次都会向函数内部传递进一个隐含的参数</p>
<p>  这个隐含的参数就是this指向的是一个对象，</p>
<p>  这个对象我们称之为函数执行的上下文对象</p>
<p>  根据函数的调用方式的不同，this会指向不同的对象</p>
<h2 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h2><p>当我们不知道参数有几个的时候</p>
<p>在调用函数时，游览器都会传递进两个隐含的参数：</p>
<p>// 1. arguments 它是一个伪数组。 </p>
<p>​       什么叫伪数组？ 长得像数组，但又不是真正的数组。</p>
<p>​       \1. 有length属性</p>
<p>​       \2. 有索引</p>
<p>​       \3. 但是没有数组的一些方法。比如说pop(), push().</p>
<p>​       \4. 伪数组也可以用for循环遍历。</p>
<p> 1.函数的上下文对像this</p>
<p>2.封装实参的对象时arguments</p>
<p>​         -arguments 是一个类数组对象，也可以叫伪数组，他也可以通过索引来操作数据，也可以获取长度</p>
<p>​        -在调用函数时，我们所传递的实参都会在arguments中保存</p>
<p>​        -arguments.length可以用来获取实参的长度</p>
<p>​        -我们即使不定义形参，也可以通过argument来使用实参</p>
<p>​                      argument【0】 表示第一实参</p>
<p>​                       argument【1】 表示第二个实参。。。</p>
<p>​          -他里边有一个属性叫做callee，</p>
<p>​                  这个属性对应一个函数对象，就是当前正在执行的函数对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jsx = getMax(1,2,5,8,9,85,100);</span><br><span class="line">function findMax() &#123;   </span><br><span class="line">    var i;    </span><br><span class="line">    var max = -Infinity;</span><br><span class="line">    for (i = 0; i &lt; arguments.length; i++) &#123; </span><br><span class="line">        if (arguments[i] &gt; max) &#123;  </span><br><span class="line">            max = arguments[i];       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是属性和方法的集合</p>
<p>什么是对象? 咱们要说的对象可不是 女朋友, 在这个世界上 任何<strong>具体事物</strong>都可以看做 对象 因为他们都有自己的特征、行为。</p>
<p>只有具体的事物才是对象 , 比如我的兰博基尼</p>
<p>属性：实物的特征</p>
<p>方法：事物的行为</p>
<h3 id="创建对象的三种方法"><a href="#创建对象的三种方法" class="headerlink" title="创建对象的三种方法"></a>创建对象的三种方法</h3><p>使用字面量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name:&#x27;张三丰&#x27;,</span><br><span class="line">  age:128;</span><br><span class="line">  sex:nan;</span><br><span class="line">  dataji: function() &#123;</span><br><span class="line">    console.log(&#x27;打太极&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key  value ==&gt;  键值对</span><br></pre></td></tr></table></figure>

<h3 id="获取对象的属性值"><a href="#获取对象的属性值" class="headerlink" title="获取对象的属性值"></a>获取对象的属性值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj.name</span><br><span class="line">obj[&#x27;age&#x27;]</span><br><span class="line">调用对象的方法</span><br><span class="line">obj.dataji(); //相当于获取到的方法，但是不调用</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="obj-‘’"><a href="#obj-‘’" class="headerlink" title="obj[‘’]"></a>obj[‘’]</h3><p>使用【】这种形式去操作属性，更加的灵活，</p>
<p>在[]中可以直接传递一个变量，这样变量值是多少就会读取那个属性</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>创建对象的方法，把对象里面一些相同的属性和方法抽象出来封装到函数里面</p>
<p>构造函数名字首字母要大写</p>
<p>构造函数不需要return 就可以返回结果</p>
<p>我们调用构造函数 必须使用 new</p>
<p>我们只要new Star() 调用函数就创建一个对象 ldh  {}</p>
<p>构造函数里 属性和方法前面必须添加 this</p>
<p>通过构造函数创建对象的过程，也叫做对象的实例化。</p>
<p>创建一个对象 也叫做实例化了一个对象。</p>
<h2 id="new关键字执行过程"><a href="#new关键字执行过程" class="headerlink" title="new关键字执行过程"></a>new关键字执行过程</h2><ol>
<li>在内存中创建了一个空对象</li>
<li>让this指向这个空对象。  可以理解为等于 this等于那个空对象</li>
<li>执行构造函数内部的代码，给这个空对象添加属性和方法</li>
<li>返回这个对象。</li>
</ol>
<h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h2><p> 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype</p>
<p>这个属性对应一个对象，这个对象就是我们所谓的原型对象。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1654586299813-b66bf371-7c1b-4edd-bd24-ee262ba2e8d5.png" alt="img"></p>
<p>如果函数作为普通函数调用prototype没有任何作用</p>
<p>  当函数以构造函数的形式调用时，他所创建的对象中都会有一个隐含的属性，</p>
<p> 指向该构造函数的原型对象，我们可以通过__proto__开访问该属性</p>
<p>原型对象就想当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象</p>
<p>​                    我们可以将对象中公共有的内容，统一设置到原型对象中</p>
<p>  当我们访问对象的一个属性或方法是，会先到对象自身中寻找，如果有则直接使用，</p>
<p>  如果没有则会去原型对象中寻找，如果找到则直接使用。</p>
<p>var mc = new MyClass()；</p>
<p> function   MyClass () {}</p>
<p>mc是通过MyClass构造函数创建的。</p>
<p>同样的创建的对象mc还有一个隐含的属性：<strong>protp</strong></p>
<p>使用in检查对象中是否含有某个属性的时，如果对象中没有但是原型中有，也会返回true</p>
<p>可以使用对象的hasOwnProperty()来检查对象中自身中是否含有该属性</p>
<p>使用改方法只有当对象中含有属性时，才会返回true</p>
<p>原型对象也是对象，所以他也有原型。</p>
<p>   当我们使用一个对象的属性或方法是，会先在自身中寻找，</p>
<p>​    自身中如果有，则直接使用，</p>
<p>​    如果没有则去原型对象中寻找，如果原型对象中有，则使用，</p>
<p>​    如果没有则去原型中的原型中寻找,直到找到Object对象的原型，</p>
<p>   Object对象的原型也有原型，如果在Object中依然没有找到，则返回undefined</p>
<p>console.log(实列.<strong>proto</strong>.<strong>proto</strong>.proto__)  值为null</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 语法糖： 简单的写法 ，换了一种方式，本质上一样</span><br><span class="line"></span><br><span class="line">// var obj = &#123;&#125;         // 是他的 var obj = new Object() 语法糖</span><br><span class="line">// var arr = []        // 是他的 var arr = new Array() 语法糖</span><br><span class="line"></span><br><span class="line"> 1. 所有的应用类型(对象，数组，函数)，都具有对象的特殊特性，可以自由扩展属性</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;   //  obj.a = 1;</span><br><span class="line">var arr = []   //  arr.b = 2; </span><br><span class="line"></span><br><span class="line">var fn = function() &#123;&#125;  // fn.c = 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 2. 所有的对象，都有一个__proto__属性,属性值是一个普通的对象.</span><br><span class="line">// __proto__也叫隐式原型  ==》 [[prototype]]</span><br><span class="line"></span><br><span class="line">console.log(obj.__proto__);</span><br><span class="line">console.log(arr.__proto__);</span><br><span class="line">console.log(fn.__proto__);</span><br><span class="line"></span><br><span class="line"> 3.所有的函数，都有一个prototype 属性，属性值也是一个普通的对象。</span><br><span class="line"></span><br><span class="line">prototype//又叫显示原型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 4. 所有对象的隐式原型(__proto__), 指向他的构造函数的显示原型(prototype)</span><br></pre></td></tr></table></figure>

<h2 id="toString"><a href="#toString" class="headerlink" title="toString()"></a>toString()</h2><p>当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值</p>
<p>console.log(对象实例.<strong>proto</strong>.<strong>proto</strong>.hasOwnProperty(toString()))</p>
<p>如果我们希望在输出对象时不输出【Object object】,可以为对象添加一个toString()方法覆盖了原型的对象</p>
<p>如果希望所有的对象的toString 都打印 可以直接修改</p>
<h2 id="垃圾回收（GC）"><a href="#垃圾回收（GC）" class="headerlink" title="垃圾回收（GC）"></a>垃圾回收（GC）</h2><p>  就想人生活的事件会产生垃圾一样，我们程序运行中也会产生垃圾</p>
<p>  垃圾积累过多以后，会导致程序运行的速度过慢。</p>
<p>所以我们需要一个垃圾回收机制，来处理程序运行中产生的垃圾。</p>
<p>  当一个对象没有任何的变量或属性对他进行引用，此时我们将永远无法操作该对象</p>
<p>​      此时这种对象就是一种垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，</p>
<p>​      所以这种垃圾我们必须清理。</p>
<p>  在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，</p>
<p>​       我们不需要也不能进行垃圾回收的操作。</p>
<p>  我们需要做的只是将不在使用的对象设置为null即可</p>
<h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><p>用来表示一个时间</p>
<p>在js中使用Date对像来表示一个时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建一个Date对像</span><br><span class="line">如果直接使用构造函数创建了一个Date对像，则会封装为当前代码执行的时间</span><br><span class="line">var d = new Date();</span><br><span class="line">创建一个指定的时间对像</span><br><span class="line">//需要在构造函数中传递一个表示时间的字符串作为参数</span><br><span class="line">日期的格式 月份/日/年 时：分：秒；</span><br><span class="line">var d2 = new Date(&quot;12/03/2016 11:10:30&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="getDate"><a href="#getDate" class="headerlink" title="getDate"></a>getDate</h3><p>获取当前日期对象是几日（1~31日）里的一天</p>
<h3 id="getDay"><a href="#getDay" class="headerlink" title="getDay"></a>getDay</h3><p>获取当前日期对象的周几</p>
<p>会返回一个0~6的值   0表示周日 其他正常；</p>
<h3 id="getMonth"><a href="#getMonth" class="headerlink" title="getMonth"></a>getMonth</h3><p>获取当前时间月份 </p>
<p>会返回一个0~11的值</p>
<p>0 表示1 月   11表示12</p>
<h3 id="getFullYear"><a href="#getFullYear" class="headerlink" title="getFullYear"></a>getFullYear</h3><p>获取当前日期对象的年份</p>
<h3 id="getTime（）"><a href="#getTime（）" class="headerlink" title="getTime（）"></a>getTime（）</h3><p>获取当前日期的时间戳</p>
<p>时间戳，指的是从格林威治标准时间的1970年1月1日，0时0分0秒 </p>
<p>​     到当前日期所花费的毫秒数（1秒= 1000毫秒）;</p>
<p>计算机底层在保存时间时使用的都是时间戳。</p>
<p>利用时间戳来测试代码的执行性能</p>
<p>案列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var start = Date.now();</span><br><span class="line">for(var i =0; i &lt;100; i++) &#123;</span><br><span class="line">  console.log(i)</span><br><span class="line">&#125;</span><br><span class="line">var end = Date.now();</span><br><span class="line">console.log(&quot;&quot; + (end - start) + &quot;&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>Math和其他的对象不同，他不是一个构造函数</p>
<p>​    他属于一个工具类不用创建对象，它里边封装了数学元素相关的属性和方法</p>
<p>比如</p>
<p>​      math.PI 表示圆周率</p>
<p>abs() 可以用来计算一个数的绝对值Math.abs();</p>
<h3 id="abs"><a href="#abs" class="headerlink" title="abs();"></a>abs();</h3><p>可以用来计算一个数的绝对值。</p>
<h3 id="ceil"><a href="#ceil" class="headerlink" title="ceil()"></a>ceil()</h3><h4 id="math-ceil"><a href="#math-ceil" class="headerlink" title="math.ceil()"></a>math.ceil()</h4><p>可以对一个数进行向上取整，小数位只要有值就自动进1</p>
<h4 id="math-floor"><a href="#math-floor" class="headerlink" title="math.floor"></a>math.floor</h4><p>可以对一个数进行向下取整，小数部分会被舍掉</p>
<h4 id="math-round"><a href="#math-round" class="headerlink" title="math.round()"></a>math.round()</h4><p>可以对一个数进行四舍五入取整。</p>
<h4 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h4><p>可以用来生成一个0~1之间的随机数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">生成一个0~10的随机数</span><br><span class="line">Math.random() * 10  //则就出现了0~10不包括0 和10</span><br><span class="line">生成一个0~x之间的随机数</span><br><span class="line">Math.round(Math.random() *20)</span><br><span class="line"></span><br><span class="line">生成一个1~10的随机数</span><br><span class="line">console.log(Math.round(Math.random() *9) + 1)</span><br><span class="line"></span><br><span class="line">生成一个x~y的随机数</span><br><span class="line">console.log(Math.round(Math.random() * （Y -X）) + X)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max()"></a>Math.max()</h4><p>可以获取多个数总的最大值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var max = Math.max(10,50,20)</span><br><span class="line">console.log(max);</span><br></pre></td></tr></table></figure>

<h4 id="math-min"><a href="#math-min" class="headerlink" title="math.min()"></a>math.min()</h4><p>与math.max相反</p>
<h4 id="Math-pow-x-y"><a href="#Math-pow-x-y" class="headerlink" title="Math.pow(x,y)"></a>Math.pow(x,y)</h4><p>返回x的y次幂</p>
<h4 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt()"></a>Math.sqrt()</h4><p>对于一个数进行开房</p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>基本数据类型，正常来说没有属性和方法；</p>
<p>当我们执行 str.length 或者str.substring()等方法和属性的时候</p>
<p>游览器后台给我们生产了一临时的对象，通过这个临时对象的属性和方法</p>
<p>之后在把这个临时对象销毁。</p>
<p>基本数据类型：</p>
<p>Number  String null undefined bigint symbol Boolean</p>
<p>引用数据类型：</p>
<p>object</p>
<p>在js中为我们提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为队象</p>
<h3 id="String-1"><a href="#String-1" class="headerlink" title="String()"></a>String()</h3><p>可以将基本数据类型转换为String队象</p>
<h3 id="Number-1"><a href="#Number-1" class="headerlink" title="Number()"></a>Number()</h3><p>可以将基本数据类型转换为Number队象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = new Number(3);</span><br><span class="line">console.log(typeof num)//object</span><br></pre></td></tr></table></figure>

<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h3><p>可以将基本数据类型转换为Boolean队象</p>
<h3 id="但是注意，我们在实际应用中不会使用基本数据类型对象"><a href="#但是注意，我们在实际应用中不会使用基本数据类型对象" class="headerlink" title="但是注意，我们在实际应用中不会使用基本数据类型对象"></a>但是注意，我们在实际应用中不会使用基本数据类型对象</h3><p>​    若果使用基本数据类型对象，在做一些比较时可能对带来一些不可逾期的问题</p>
<h2 id="方法和属性只能添加给对象，不能添加给基本数据类型"><a href="#方法和属性只能添加给对象，不能添加给基本数据类型" class="headerlink" title="方法和属性只能添加给对象，不能添加给基本数据类型"></a>方法和属性只能添加给对象，不能添加给基本数据类型</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655346048629-d5d6b48e-7d89-4a97-99ee-b82520a85647.png" alt="img"></p>
<p>当我们对一些基本数据类型的值去调用属性和方法时</p>
<p>​    游览器会临时使用包装类将其转换为对象，然后在调用对象的属性和方法</p>
<p>​    调用完以后，在将其转换为基本数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = 123；</span><br><span class="line">s = s.toString();</span><br><span class="line"></span><br><span class="line">s.hello = &#x27;你好&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="字符串相关的方法"><a href="#字符串相关的方法" class="headerlink" title="字符串相关的方法"></a>字符串相关的方法</h2><p>var str = “hello “</p>
<p>在底层字符串是以字符数组的形式保存的</p>
<p> 【’h’,’e’,’l’,’l’,’o’】</p>
<p>console.log(str.length); //数组字符串的长度.</p>
<p>length可以用来获取我们字符串的长度</p>
<h3 id="cartAt"><a href="#cartAt" class="headerlink" title="cartAt()"></a>cartAt()</h3><p>可以返回字符串中指定的位置的字符</p>
<p>根据我们的索引获取指定的字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = &#x27;hell0kk&#x27;</span><br><span class="line">var result = str.cahrAt(6);  //k</span><br></pre></td></tr></table></figure>

<h3 id="charCode"><a href="#charCode" class="headerlink" title="charCode()"></a>charCode()</h3><p>获取指定位置字符的字符编码  （unicode编码）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result = str.cahrCodeAt(0);  </span><br></pre></td></tr></table></figure>

<h3 id="fromCharCode"><a href="#fromCharCode" class="headerlink" title="fromCharCode()"></a>fromCharCode()</h3><p>可以根据字符编码去获取字符，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = String.fromCharCode(73)  //通过构造函数对象构造的</span><br><span class="line">console.log(result)</span><br></pre></td></tr></table></figure>

<h3 id="contact-1"><a href="#contact-1" class="headerlink" title="contact()"></a>contact()</h3><p>   可以用来连接两个或多个字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = str.contact(&quot;你好&quot;,&quot;再见&quot;)//对原数组不影响</span><br></pre></td></tr></table></figure>

<h3 id="indexof"><a href="#indexof" class="headerlink" title="indexof()"></a>indexof()</h3><p>改方法可以检索一个字符串中是否含有指定的内容</p>
<p>如果字符串中含有该内容，则会返归其第一次出现的索引</p>
<p>​        如果没有找到指定的内容，则返回-1</p>
<p>可以指定一个第二个参数，指定开始查找的位置</p>
<p>​         </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;helloe&quot;;</span><br><span class="line">result =  str.indexof(&#x27;e&#x27;，2)索引为2的开始找</span><br><span class="line">console.log(result)//5   </span><br></pre></td></tr></table></figure>

<h3 id="lastIndexOF"><a href="#lastIndexOF" class="headerlink" title="lastIndexOF()"></a>lastIndexOF()</h3><p>改方法的用法和indexof（）一样</p>
<p>​      不同的是indexof()是从前往后找</p>
<p>​       而lastIndexOf()是从后往前找（最后一次出现时所在位置的索引）</p>
<p>也可以指定开始查找的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;helloe&quot;;</span><br><span class="line">result =  str.indexof(&#x27;e&#x27;，2)索引为2的开始找</span><br><span class="line">result = str.lastIndexOf(&quot;h&quot;,5)</span><br><span class="line">console.log(result)//5   </span><br></pre></td></tr></table></figure>

<h3 id="slice（）"><a href="#slice（）" class="headerlink" title="slice（）"></a>slice（）</h3><p>   可以从字符串中截取指定的内容</p>
<p>​    不会影响原来字符串，而是将截取到的内容返回</p>
<p>—参数</p>
<p>​            第一个，开始位置的索引（包括开始位置）</p>
<p>​             第二个，结束位置的索引（不包括结束位置）</p>
<p>​                                    如果省略第二个参数，负数的话将会从后边计算。</p>
<h3 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h3><p>​         可以用来截取一个字符串，可以slice（）类似</p>
<p>​          参数        </p>
<p>​                    第一个，开始截取位置的索引（包括开始位置）</p>
<p>​                     第二个，结束位置的索引（不包括结束位置）</p>
<p>​                     不同的是这个方法不能接受负值作为参数，</p>
<p>​                         如果传递了一个负值，则默认使用0</p>
<p>​                     而且他还自动调整参数的位置，如果第二参数小于第一个，则自动交换</p>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>替换字符 replace(“被替换的”，“替换为的字符”);</p>
<p>返回替换后的字符串 一次只能替换一次</p>
<h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>可以将字符串拆分为一个数组，返回的是一个数组。不改变原数组</p>
<p>​     参数</p>
<p>​                需要一个字符串作为参数，将会根据字符串去拆分数组</p>
<p>str.split</p>
<p>如果传递一个空串作为参数，则会将每个字符拆分为数组中的一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;dddd&#x27;;</span><br><span class="line">console.log(str.split(&#x27;&#x27;))  </span><br><span class="line">[&#x27;d&#x27;,&#x27;d&#x27;,&#x27;d&#x27;,&#x27;d&#x27;]  将字符串  拆分为一个数组</span><br></pre></td></tr></table></figure>

<h3 id="toUpCase"><a href="#toUpCase" class="headerlink" title="toUpCase()"></a>toUpCase()</h3><p>将一个字符串转换为大写并返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;dddd&#x27;;</span><br><span class="line">console.log(str.toUpperCase())</span><br><span class="line">      DDDD</span><br></pre></td></tr></table></figure>

<h3 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase()"></a>toLowerCase()</h3><h2 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h2><p>栈  基本数据类型  存在栈里面</p>
<p>堆   引用数据类型  变量名存在栈里面，值存在推里面</p>
<p>所有基本（原始）数据类型默认执行深拷贝（Boolean, null , Undefined , Number, String,Symbol , BigInt）</p>
<p>基本数据类型的赋值</p>
<p>在栈内存新开辟一个空间，把num的复制一份，给num2;</p>
<p>两个变量互不影响</p>
<p>引用类型的赋值 </p>
<p>他们在栈内存中存的地址是一样对，指向同一个堆内存空间。</p>
<h2 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h2><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p> 用于定义一些字符串规则，</p>
<ul>
<li>​    计算机可以根据正则表达式，来检查一个字符串是否符合规则</li>
<li>​     获取将字符串中符合规则的内容提取出来</li>
</ul>
<p>var 变量 = new RegExp(“正则表达式”,”匹配模式”);</p>
<p>使用typeof 检查正则对象，会返回object</p>
<p>var reg = new RegExp(“a”);这个正则表达式可以来检查一个字符串中是否含有a</p>
<p>在构造函数中可以传递一个匹配模式作为第二个参数</p>
<p>​       可以是</p>
<p>​                 i   忽略大小写 </p>
<p>​                 g  全局匹配模式</p>
<h3 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h3><p> 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则</p>
<p>​     如果符合则返回true,否则返回false</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var reg = new RegExp(&quot;a&quot;);</span><br><span class="line">var result = reg.test(str)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用字面量来创建正则表达式"><a href="#使用字面量来创建正则表达式" class="headerlink" title="使用字面量来创建正则表达式"></a>使用字面量来创建正则表达式</h3><p>语法：var 变量 = /正则表达式/匹配模式</p>
<p>reg = /a/i;</p>
<p>使用字面量的方式创建更加简单</p>
<p>使用构造函数创建更加灵活</p>
<p>创建一个正则表达式，检查一个字符串中是否有a或b</p>
<p>使用 | 表示或者的意思</p>
<p>reg = /a | b | c/;</p>
<p>创建一个正则表达式检查一个字符串中是否有字母</p>
<p>reg = /a|d|a|g/</p>
<p>[]里面的内容也是或的关系</p>
<p>[ab] == a | b</p>
<p>[a-z] 任意小写字母</p>
<p>[A-Z] 任意大写字母</p>
<p>[A-z] 任意字母</p>
<p>//检查一个字符串中是否含有abc 或adc 或aec</p>
<p>reg = /a[bde]c/   ac是共有的  随便一个bde就行</p>
<p>reg = /[ab]/   检查是否含有一个a或者b</p>
<p>[^ ] 除了什么以外的</p>
<h3 id="split-1"><a href="#split-1" class="headerlink" title="split()"></a>split()</h3><p>可以将一个字符串拆分为一个数组作为参数，这样方法将会根据正则表达式去拆分字符串</p>
<p>方法可以传递一个正则表达式</p>
<p>这个方法即使不指定全局匹配，也会被匹配模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = &quot;a1b2c34d5&quot;;</span><br><span class="line">var result = str.split(/[A-z]/); // 根据任意字母来将字符串拆分=意思是删除</span><br><span class="line">console.log(result) 1,2,3,4,5</span><br></pre></td></tr></table></figure>

<h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p> 可以搜索字符创中是否含有指定内容</p>
<p>如果搜索到指定内容则会返回第一次出现的索引，如果没有搜索到返回-1</p>
<p>他可以接受一个正则表达式作为参数，然后根据正则表达式去检索字符串</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26755557/1655038501943-320ff8ea-4a7a-4392-90f0-adc6e6cde422.png" alt="img"></p>
<h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><p>可以根据正则表达式从一个字符串中将符合条件的内容提取出来</p>
<p>默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索</p>
<p>我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容</p>
<p>可以为一个正则表达式设置多个匹配模式，且顺序无所谓</p>
<p>match（）会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果</p>
<p>str = ‘1a2c3v4b5n5n5f’;</p>
<p>result = str.match(/A-z/g)</p>
<h3 id="replace-1"><a href="#replace-1" class="headerlink" title="replace()"></a>replace()</h3><p>可以将字符串中国指定内容替换为新的内容</p>
<p>  参数</p>
<p>​             被替换的内容</p>
<p>​             新的内容</p>
<p>默认只会替换第一个</p>
<p>result = str.replace(/a/g ,”@_@”) 同时也可以设置为空串删掉内容</p>
<h3 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h3><p>创建一个字符串中国检查一个字符串中是否含有aaa</p>
<p>var reg= /aaaaaaaaaaaaaaaaaaaa/采用清楚的方式</p>
<p>量词</p>
<p>​      通过量词可以设置一个内容出现的次数</p>
<p>​      量词只对他前边的内容起作用</p>
<ul>
<li>​        {n} 正好出现n次</li>
<li>​         {n,m} 出现n~m次</li>
<li>​          {3，}3次以上</li>
<li>​          +  至少一个，相当于{1，}</li>
<li>​           * 表示0个或多个</li>
<li>​            ？0个或1个</li>
</ul>
<p>var reg = /a{3}/;    //aaa</p>
<p>var reg = /(ab){3}/ababab</p>
<p>​        reg = /ab{3,}c/;</p>
<p>​        reg = /ab+c/;</p>
<p>​        reg = /ab * c/;</p>
<p>​        reg = /ab?c/;</p>
<p>console.log(reg.test(“aaabc”))</p>
<p>检查一个a是否以a开头</p>
<p> var reg = /^a/   匹配开头的a</p>
<p>var reg = /a$/     匹配结尾的a</p>
<h3 id="检查一个手机号是否是一个合法手机号"><a href="#检查一个手机号是否是一个合法手机号" class="headerlink" title="检查一个手机号是否是一个合法手机号"></a>检查一个手机号是否是一个合法手机号</h3><p>手机号规则：</p>
<ol>
<li> 以1开头</li>
<li>第二位3-9任意数字</li>
<li>三位以后任意数字9个</li>
</ol>
<p>^a    [3-9]   [0-9]{9}$ </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var phoneStr = &quot;13567890123&quot;;</span><br><span class="line">var phoneReg = /^1[3-9][0-9]&#123;9&#125;$/;</span><br><span class="line">console.log(phoneReg.test(phoneStr));</span><br></pre></td></tr></table></figure>

<h3 id="语法二"><a href="#语法二" class="headerlink" title="语法二"></a>语法二</h3><p>检查一个字符串中是否含有 .</p>
<p>. 表示任意字符</p>
<p>在正则表达式中使用\作为转义字符</p>
<p>. 来表示 .</p>
<p>注意使用构造函数时，由于他的参数是一个字符串，而\是字符串中转义字符</p>
<p>  如果要使用\则需要使用\来代替</p>
<p>\w      表示任意字母、数字和_    [A-z0-9_]</p>
<p>\W     除了字母、数字、_     [^A-z0-9_]</p>
<p>\d      任意的数字     [0-9]</p>
<p>\D      除了数字   [^0-9]</p>
<p>\s       空格</p>
<p>\S       除了空格</p>
<p>\b       单词边界     (独立的单词)               reg = /\bchild\b/         </p>
<p>\B       除了单词边界</p>
<p>去除掉字符串中的空格   去除空格就是使用“” 来替换</p>
<p>var str = “        str                ”            console.log(str)       str = str.replace(/\s/g , “”/)</p>
<p>去除开头和结尾的空格  /^\s*/     /\s*$/</p>
<p>和写   /^\s*|\s*$/</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="John Doe"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">59k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
</html>
